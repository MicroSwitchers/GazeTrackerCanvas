<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gaze Tracker Canvas</title>
    <script src="https://unpkg.com/konva@9.3.11/konva.min.js"></script>
    <script src="https://unpkg.com/gifler@0.1.0/gifler.min.js"></script> <!-- Added gifler for better GIF handling -->
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            display: flex;
            background-color: #000000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #toolbar {
            width: 60px;
            height: 100vh;
            padding: 8px 4px;
            box-shadow: 2px 0 8px rgba(0,0,0,0.2);
            display: block;
            transition: all 0.3s ease;
            background: linear-gradient(180deg, #3a3836 0%, #2a2826 100%);
            border-right: 1px solid rgba(255,255,255,0.1);
            overflow-y: auto;
            overflow-x: hidden;
        }

        .toolbar-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100%;
            padding-bottom: 100px; /* Ensure scrollable space */
        }

        .toolbar-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px 0;
            width: 100%;
        }

        .toolbar-group-label {
            font-size: 10px;
            color: rgba(255,255,255,0.6);
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
        }

        .toolbar-divider {
            width: 80%;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            margin: 8px 0;
        }

        #container {
            flex: 1;
            height: 100vh;
            background-color: #000000;
            transition: background-color 0.3s ease;
            position: relative;
        }
        
        #container.drag-over {
            outline: 3px dashed rgba(52, 199, 89, 0.5);
            outline-offset: -10px;
            background-color: rgba(52, 199, 89, 0.05);
        }

        .toolbar-button, .color-swatch {
            width: 44px;
            height: 44px;
            margin: 3px;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .toolbar-button {
            background: linear-gradient(145deg, rgba(80, 80, 80, 0.3), rgba(60, 60, 60, 0.2));
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #e0e0e0;
            backdrop-filter: blur(10px);
        }

        .toolbar-button:hover {
            background: linear-gradient(145deg, rgba(120, 120, 120, 0.4), rgba(100, 100, 100, 0.3));
            border-color: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .toolbar-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        .color-swatch {
            border: 2px solid rgba(255, 255, 255, 0.3);
            position: relative;
            overflow: hidden;
        }

        .color-swatch::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: inherit;
            border-radius: inherit;
        }

        .color-swatch:hover {
            transform: scale(1.1);
            border-color: rgba(255, 255, 255, 0.6);
            box-shadow: 0 0 16px rgba(255, 255, 255, 0.4);
        }

        .hidden {
            display: none;
        }

        #gif-container {
            position: absolute;
            left: -9999px;
            top: -9999px;
            visibility: hidden;
            pointer-events: none;
        }

        #textPopup {
            display: none;
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(145deg, #4a4642, #3a3632);
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.6);
            z-index: 1000;
            border-radius: 16px;
            width: 320px;
            max-height: 90vh;
            overflow-y: auto;
            overflow-x: hidden;
            backdrop-filter: blur(20px);
        }

        #textPopupTitleBar {
            background: linear-gradient(135deg, #5a5652, #4a4642);
            color: white;
            padding: 16px 20px;
            cursor: move;
            user-select: none;
            display: flex;
            justify-content: center;
            align-items: center;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        #textPopupTitle {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
            text-align: center;
            letter-spacing: 0.5px;
        }

        #textPopupContent {
            padding: 0;
        }

        .text-form-section {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 12px;
            padding: 24px;
            margin: 20px 24px;
            position: relative;
        }

        .text-form-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, rgba(52, 199, 89, 0.6), rgba(52, 199, 89, 0.2));
            border-radius: 12px 12px 0 0;
        }

        .text-form-section-title {
            margin: 0 0 20px 0;
            font-size: 16px;
            font-weight: 600;
            color: #ffffff;
            display: flex;
            align-items: center;
            gap: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .text-form-section-icon {
            font-size: 20px;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(52, 199, 89, 0.2);
            border-radius: 6px;
        }

        .text-form-row {
            margin-bottom: 16px;
        }

        .text-form-row:last-child {
            margin-bottom: 0;
        }

        .text-form-label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .text-form-description {
            font-size: 10px;
            color: rgba(255,255,255,0.6);
            margin-bottom: 8px;
            line-height: 1.3;
        }

        .text-form-input {
            width: 100%;
            padding: 12px 16px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            color: white;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .text-form-input:focus {
            outline: none;
            border-color: rgba(52, 199, 89, 0.5);
            background: rgba(0, 0, 0, 0.6);
            box-shadow: 0 0 0 2px rgba(52, 199, 89, 0.1);
        }

        .text-form-input[type="color"] {
            height: 50px;
            padding: 4px;
            cursor: pointer;
        }

        .text-form-slider-container {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .text-form-slider {
            flex: 1;
            height: 6px;
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .text-form-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #34c759;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid #ffffff;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        .text-form-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #34c759;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid #ffffff;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        .text-form-value-display {
            background: rgba(52, 199, 89, 0.2);
            color: #ffffff;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            min-width: 50px;
            text-align: center;
            border: 1px solid rgba(52, 199, 89, 0.3);
        }

        .text-preview-container {
            margin: 20px 24px;
        }

        .text-preview-title {
            font-size: 14px;
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        #textPreview {
            background: rgba(0, 0, 0, 0.6);
            border: 2px dashed rgba(255,255,255,0.3);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            min-height: 60px;
            cursor: move;
            transition: all 0.3s ease;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        #textPreview::before {
            content: '⊞';
            position: absolute;
            top: 8px;
            right: 12px;
            font-size: 14px;
            color: rgba(255,255,255,0.4);
        }

        #textPreview:hover {
            background: rgba(0, 0, 0, 0.8);
            border-color: rgba(52, 199, 89, 0.5);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .button-group {
            display: flex;
            gap: 8px;
        }

        .btn {
            flex: 1;
            padding: 12px 16px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #6b6862, #5a5652);
            color: white;
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, #7b7872, #6a6662);
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: rgba(255,255,255,0.8);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .btn-secondary:hover {
            background: rgba(255,255,255,0.2);
            color: white;
        }

        .assets-panel {
            position: fixed;
            right: -200px;
            top: 0;
            width: 200px;
            height: 100vh;
            background: linear-gradient(180deg, #3a3836 0%, #2a2826 100%);
            box-shadow: -4px 0 16px rgba(0,0,0,0.3);
            transition: right 0.3s ease;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            border-left: 1px solid rgba(255,255,255,0.1);
        }

        .assets-panel.expanded {
            right: 0;
        }

        .assets-panel-toggle {
            position: absolute;
            left: -40px;
            top: 20px;
            width: 40px;
            height: 50px;
            background: linear-gradient(135deg, #3a3836, #2a2826);
            border: 1px solid rgba(255,255,255,0.1);
            border-right: none;
            border-radius: 8px 0 0 8px;
            cursor: pointer;
            font-size: 16px;
            color: #e0e0e0;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .assets-panel-toggle:hover {
            background: linear-gradient(135deg, #4a4642, #3a3632);
        }

        .assets-panel-header {
            padding: 20px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .assets-panel-title {
            margin: 0;
            font-size: 16px;
            font-weight: 600;
            color: #e0e0e0;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .assets-panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }
        
        .assets-panel-section-title {
            font-size: 12px;
            color: rgba(255,255,255,0.6);
            margin: 16px 0 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 4px;
        }

        .asset-container {
            position: relative;
            width: 100%;
            height: 120px;
            margin-bottom: 12px;
            border-radius: 8px;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s ease;
        }

        .asset-container:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            border-color: rgba(255,255,255,0.3);
        }

        .asset-thumbnail {
            width: 100%;
            height: 100%;
            object-fit: cover;
            cursor: grab;
            transition: transform 0.3s ease;
        }
        
      .asset-thumbnail:active {
            cursor: grabbing;
        }

        .asset-thumbnail:hover {
            transform: scale(1.05);
        }

        .asset-delete-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            background: rgba(255, 59, 48, 0.9);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: all 0.3s ease;
        }

        .asset-container:hover .asset-delete-btn {
            opacity: 1;
        }

        .asset-delete-btn:hover {
            background: #ff3b30;
            transform: scale(1.1);
        }

        .gif-indicator {
            position: absolute;
            top: 8px;
            left: 8px;
            background: rgba(52, 199, 89, 0.9);
            color: white;
            padding: 2px 6px;
            font-size: 10px;
            border-radius: 4px;
            font-weight: bold;
        }

        #animationSettingsMenu {
            display: none;
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(145deg, #4a4642, #3a3632);
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.6);
            z-index: 1000;
            width: 400px;
            max-height: 90vh;
            overflow-y: auto;
            overflow-x: hidden;
            backdrop-filter: blur(20px);
        }

        .settings-header {
            background: linear-gradient(135deg, #5a5652, #4a4642);
            padding: 20px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            border-radius: 16px 16px 0 0;
        }

        .settings-title {
            margin: 0;
            font-size: 20px;
            font-weight: 600;
            color: white;
            text-align: center;
            letter-spacing: 0.5px;
        }

        .settings-content {
            padding: 24px;
        }

        .settings-section {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 24px;
            position: relative;
        }

        .settings-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, rgba(52, 199, 89, 0.6), rgba(52, 199, 89, 0.2));
            border-radius: 12px 12px 0 0;
        }

        .settings-section-title {
            margin: 0 0 20px 0;
            font-size: 18px;
            font-weight: 600;
            color: #ffffff;
            display: flex;
            align-items: center;
            gap: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .settings-section-icon {
            font-size: 24px;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(52, 199, 89, 0.2);
            border-radius: 8px;
        }

        .settings-row {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 16px;
            align-items: center;
            margin-bottom: 20px;
            padding: 12px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .settings-row:last-child {
            margin-bottom: 0;
        }

        .settings-row-label {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .settings-row-title {
            font-size: 14px;
            font-weight: 600;
            color: #ffffff;
            margin: 0;
        }

        .settings-row-description {
            font-size: 11px;
            color: rgba(255,255,255,0.6);
            margin: 0;
        }

        .settings-row-control {
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 140px;
            flex-shrink: 0;
        }

        .settings-value-display {
            background: rgba(52, 199, 89, 0.2);
            color: #ffffff;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            min-width: 45px;
            text-align: center;
            border: 1px solid rgba(52, 199, 89, 0.3);
            flex-shrink: 0;
        }

        .settings-input-range {
            flex: 1;
            min-width: 80px;
            height: 6px;
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .settings-input-range::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #34c759;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid #ffffff;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        .settings-input-number {
            width: 60px;
            padding: 6px 8px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            color: white;
            font-size: 12px;
            text-align: center;
        }

        .settings-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin-top: 32px;
            padding-top: 24px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        .loading-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 24px 32px;
            border-radius: 12px;
            z-index: 2000;
            display: none;
            font-size: 14px;
            font-weight: 500;
        }

        .folder-loading-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 32px 48px;
            border-radius: 16px;
            z-index: 2000;
            display: none;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }

        .folder-loading-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 16px;
        }

        .folder-loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255,255,255,0.2);
            border-top-color: #34c759;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .folder-loading-text {
            font-size: 16px;
            font-weight: 600;
            margin: 0;
        }

        .folder-loading-details {
            font-size: 12px;
            color: rgba(255,255,255,0.6);
            margin: 0;
        }

        .folder-loading-progress {
            width: 200px;
            height: 4px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 8px;
        }

        .folder-loading-progress-bar {
            height: 100%;
            background: #34c759;
            transition: width 0.3s ease;
            width: 0%;
        }

        .error-message {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #ff3b30;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            z-index: 2000;
            display: none;
            max-width: 80%;
            text-align: center;
            font-weight: 500;
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.3);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255,255,255,0.5);
        }

        .toolbar-help {
            display: none;
        }
        @media (max-width: 768px) {
            #toolbar {
                width: 50px;
            }
            
            .toolbar-button, .color-swatch {
                width: 36px;
                height: 36px;
                font-size: 16px;
            }
            
            #textPopup {
                width: 90%;
                max-width: 320px;
            }
            
            .assets-panel {
                width: 180px;
                right: -180px;
            }
        }
    </style>
</head>
<body>
    <div id="toolbar" role="toolbar" aria-label="Image editing tools">
        <div class="toolbar-content">
            <div class="toolbar-group">
                <div class="toolbar-group-label">Files</div>
                <button class="toolbar-button" onclick="document.getElementById('file-input').click();" aria-label="Upload images and videos" title="Upload Media">📁</button>
                <button class="toolbar-button" onclick="document.getElementById('folder-input').click();" aria-label="Upload folder" title="Upload Folder">📂</button>
                <button class="toolbar-button" id="setBackgroundImage" aria-label="Set Background Image" title="Set Background Image">▧</button>
                <button class="toolbar-button" id="fullscreenToggle" aria-label="Toggle fullscreen" title="Toggle Fullscreen - Press F11">⛶</button>
            </div>
            
            <div class="toolbar-divider"></div>
            
            <div class="toolbar-group">
                <div class="toolbar-group-label">Edit</div>
                <button class="toolbar-button" id="addText" aria-label="Add text" title="Add Text">T</button>
                <button class="toolbar-button" id="increaseSize" aria-label="Increase size" title="Increase Size">+</button>
                <button class="toolbar-button" id="decreaseSize" aria-label="Decrease size" title="Decrease Size">-</button>
                <button class="toolbar-button" id="deleteItem" aria-label="Delete item" title="Delete Item">×</button>
            </div>
            
            <div class="toolbar-divider"></div>
            
            <div class="toolbar-group">
                <div class="toolbar-group-label">Layer</div>
                <button class="toolbar-button" id="moveUp" aria-label="Move layer up" title="Move Layer Up - Press Ctrl+↑">↑</button>
                <button class="toolbar-button" id="moveDown" aria-label="Move layer down" title="Move Layer Down - Press Ctrl+↓">↓</button>
            </div>
            
            <div class="toolbar-divider"></div>
            
            <div class="toolbar-group">
                <div class="toolbar-group-label">Animate</div>
                <button class="toolbar-button" id="shakeButton" aria-label="Shake item" title="Shake Animation - Press Ctrl+1">⇄</button>
                <button class="toolbar-button" id="circleButton" aria-label="Circular motion" title="Circle Animation - Press Ctrl+2">⟳</button>
                <button class="toolbar-button" id="flipButton" aria-label="Flip direction" title="Flip Direction - Press Ctrl+4">⮎</button>
                <button class="toolbar-button" id="animationSettings" aria-label="Animation Settings" title="Animation Settings - Press Ctrl+3">⚙</button>
            </div>
            
            <div class="toolbar-divider"></div>
            
            <div class="toolbar-group">
                <div class="toolbar-group-label">Theme</div>
                <button class="color-swatch" style="background-color: #faf7e2;" title="Light Buff" data-color="#faf7e2" aria-label="Light Background"></button>
                <button class="color-swatch" style="background-color: #b8b6a8;" title="Buff" data-color="#b8b6a8" aria-label="Medium Background"></button>
                <button class="color-swatch" style="background-color: #37342e;" title="Dark Buff" data-color="#37342e" aria-label="Dark Background"></button>
                <button class="color-swatch" style="background-color: #000000;" title="Black" data-color="#000000" aria-label="Black Background"></button>
            </div>
        </div>
    </div>
    </div>
    
    <main id="container" role="main"></main>

    <div id="gif-container"></div>
    <div id="loadingIndicator" class="loading-indicator">Loading...</div>
    <div id="folderLoadingIndicator" class="folder-loading-indicator">
        <div class="folder-loading-content">
            <div class="folder-loading-spinner"></div>
            <p class="folder-loading-text">Loading folder contents...</p>
            <p class="folder-loading-details">
                <span id="folderLoadingCount">0</span> / <span id="folderLoadingTotal">0</span> files
            </p>
            <div class="folder-loading-progress">
                <div class="folder-loading-progress-bar" id="folderLoadingProgress"></div>
            </div>
        </div>
    </div>
    <div id="errorMessage" class="error-message"></div>

    <input type="file" id="file-input" class="hidden" accept="image/jpeg, image/png, image/gif, video/mp4, video/webm, video/ogg" multiple>
    <input type="file" id="folder-input" class="hidden" webkitdirectory directory multiple>
    <input type="file" id="background-image-input" class="hidden" accept="image/jpeg, image/png">

    <div id="textPopup" role="dialog" aria-labelledby="textPopupTitle">
        <div id="textPopupTitleBar">
            <h3 id="textPopupTitle">Text Editor</h3>
        </div>
        <div id="textPopupContent">
            <div class="text-preview-container">
                <div class="text-preview-title">Live Preview</div>
                <div id="textPreview" draggable="true">Preview Text</div>
                <div class="text-form-description" style="margin-top: 8px; text-align: center;">Drag this preview to the canvas to place text</div>
            </div>
            
            <div class="text-form-section">
                <h4 class="text-form-section-title">
                    <div class="text-form-section-icon">📝</div>
                    <div>Text Content</div>
                </h4>
                
                <div class="text-form-row">
                    <label class="text-form-label" for="popupTextInput">Text Content</label>
                    <div class="text-form-description">Enter the text you want to display on the canvas</div>
                    <input type="text" id="popupTextInput" class="text-form-input" placeholder="Enter your text here..." />
                </div>
            </div>
            
            <div class="text-form-section">
                <h4 class="text-form-section-title">
                    <div class="text-form-section-icon">🎨</div>
                    <div>Appearance Settings</div>
                </h4>
                
                <div class="text-form-row">
                    <label class="text-form-label" for="colorPicker">Text Color</label>
                    <div class="text-form-description">Choose the color for your text (auto-adjusts for contrast)</div>
                    <input type="color" id="colorPicker" class="text-form-input" value="#ffffff" />
                </div>
                
                <div class="text-form-row">
                    <label class="text-form-label" for="fontPicker">Font Family</label>
                    <div class="text-form-description">Select a font style for better readability</div>
                    <select id="fontPicker" class="text-form-input">
                        <option value="Arial">Arial (Recommended)</option>
                        <option value="Georgia">Georgia</option>
                        <option value="Times New Roman">Times New Roman</option>
                        <option value="Verdana">Verdana</option>
                        <option value="Comic Sans MS">Comic Sans MS</option>
                        <option value="Impact">Impact (Bold)</option>
                        <option value="Courier New">Courier New</option>
                    </select>
                </div>
                
                <div class="text-form-row">
                    <label class="text-form-label" for="fontSizeSlider">Font Size</label>
                    <div class="text-form-description">Adjust text size for optimal visibility</div>
                    <div class="text-form-slider-container">
                        <input type="range" id="fontSizeSlider" class="text-form-slider" min="12" max="72" value="24" />
                        <div class="text-form-value-display" id="fontSizeValue">24px</div>
                    </div>
                </div>
            </div>
            
            <div class="button-group" style="margin: 24px;">
                <button class="btn btn-primary" id="addTextButton">Add to Canvas</button>
                <button class="btn btn-secondary" id="cancelTextButton">Cancel</button>
            </div>
        </div>
    </div>

    <div id="assetsPanel" class="assets-panel">
        <button id="assetsPanelToggle" class="assets-panel-toggle" aria-label="Toggle assets panel">◀</button>
        <div class="assets-panel-header">
            <h3 class="assets-panel-title">Media Library</h3>
        </div>
        <div class="assets-panel-content">
            <h4 class="assets-panel-section-title">Other Media</h4>
            <div id="assetsList"></div>
            <h4 class="assets-panel-section-title">Background Images</h4>
            <div id="backgroundAssetsList"></div>
        </div>
    </div>

    <div id="animationSettingsMenu">
        <div class="settings-header">
            <h3 class="settings-title">Animation Settings</h3>
        </div>
        <div class="settings-content">
            <div class="settings-section">
                <h4 class="settings-section-title">
                    <div class="settings-section-icon">⇄</div>
                    <div>
                        <div>Shake Animation</div>
                        <div style="font-size: 11px; color: rgba(255,255,255,0.6); font-weight: 400;">Horizontal back-and-forth movement</div>
                    </div>
                </h4>
                
                <div class="settings-row">
                    <div class="settings-row-label">
                        <div class="settings-row-title">Animation Speed</div>
                        <div class="settings-row-description">How fast the shaking motion occurs</div>
                    </div>
                    <div class="settings-row-control">
                        <input type="range" id="shakeSpeed" class="settings-input-range" min="0.1" max="1.3" step="0.1" value="0.7">
                        <div class="settings-value-display" id="shakeSpeedValue">0.7x</div>
                    </div>
                </div>
                
                <div class="settings-row">
                    <div class="settings-row-label">
                        <div class="settings-row-title">Repetitions</div>
                        <div class="settings-row-description">Number of complete shake cycles</div>
                    </div>
                    <div class="settings-row-control">
                        <input type="number" id="shakeRepetitions" class="settings-input-number" min="1" max="10" value="5">
                    </div>
                </div>
                
                <div class="settings-row">
                    <div class="settings-row-label">
                        <div class="settings-row-title">Movement Distance</div>
                        <div class="settings-row-description">How far the object moves left and right</div>
                    </div>
                    <div class="settings-row-control">
                        <input type="range" id="shakeDistance" class="settings-input-range" min="10" max="200" step="10" value="100">
                        <div class="settings-value-display" id="shakeDistanceValue">100px</div>
                    </div>
                </div>
            </div>
            
            <div class="settings-section">
                <h4 class="settings-section-title">
                    <div class="settings-section-icon">⟳</div>
                    <div>
                        <div>Circle Animation</div>
                        <div style="font-size: 11px; color: rgba(255,255,255,0.6); font-weight: 400;">Circular orbital movement pattern</div>
                    </div>
                </h4>
                
                <div class="settings-row">
                    <div class="settings-row-label">
                        <div class="settings-row-title">Animation Speed</div>
                        <div class="settings-row-description">How fast the circular motion occurs</div>
                    </div>
                    <div class="settings-row-control">
                        <input type="range" id="circleSpeed" class="settings-input-range" min="0.1" max="2" step="0.1" value="1">
                        <div class="settings-value-display" id="circleSpeedValue">1x</div>
                    </div>
                </div>
                
                <div class="settings-row">
                    <div class="settings-row-label">
                        <div class="settings-row-title">Repetitions</div>
                        <div class="settings-row-description">Number of complete circular rotations</div>
                    </div>
                    <div class="settings-row-control">
                        <input type="number" id="circleRepetitions" class="settings-input-number" min="1" max="10" value="5">
                    </div>
                </div>
                
                <div class="settings-row">
                    <div class="settings-row-label">
                        <div class="settings-row-title">Circle Radius</div>
                        <div class="settings-row-description">Size of the circular movement path</div>
                    </div>
                    <div class="settings-row-control">
                        <input type="range" id="circleRadius" class="settings-input-range" min="10" max="200" step="10" value="100">
                        <div class="settings-value-display" id="circleRadiusValue">100px</div>
                    </div>
                </div>
            </div>
            
            <div class="settings-section">
                <h4 class="settings-section-title">
                    <div class="settings-section-icon">⮎</div>
                    <div>
                        <div>Flip Animation</div>
                        <div style="font-size: 11px; color: rgba(255,255,255,0.6); font-weight: 400;">Horizontal flip to change direction</div>
                    </div>
                </h4>
                
                <div class="settings-row">
                    <div class="settings-row-label">
                        <div class="settings-row-title">Animation Speed</div>
                        <div class="settings-row-description">How fast the flipping motion occurs</div>
                    </div>
                    <div class="settings-row-control">
                        <input type="range" id="flipSpeed" class="settings-input-range" min="0.3" max="2" step="0.1" value="1">
                        <div class="settings-value-display" id="flipSpeedValue">1x</div>
                    </div>
                </div>
                
                <div class="settings-row">
                    <div class="settings-row-label">
                        <div class="settings-row-title">Repetitions</div>
                        <div class="settings-row-description">Number of complete flip cycles</div>
                    </div>
                    <div class="settings-row-control">
                        <input type="number" id="flipRepetitions" class="settings-input-number" min="1" max="5" value="1">
                    </div>
                </div>
            </div>
            
            <div class="settings-buttons">
                <button class="btn btn-primary" id="saveAnimationSettings">Apply Settings</button>
                <button class="btn btn-secondary" id="closeAnimationSettings">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // Global variables to store animation settings and Konva objects
        let shakeSettings = { speed: 0.7, repetitions: 5, distance: 100 };
        let circleSettings = { speed: 1, repetitions: 5, radius: 100 };
        let flipSettings = { speed: 1, repetitions: 1 };
        let stage, layer, transformer, backgroundLayer; // Added backgroundLayer
        let activeGifAnimations = new Map(); // Track active GIF animations
        let activeAnimations = new Map(); // Track all active animations
        let mediaElements = new Map(); // Track all media elements for cleanup
        let assetCache = new Map(); // Cache loaded assets for instant dragging
        let currentBackgroundNode = null; // Global variable to hold the current background image Konva node
        let lastSelectedNode = null; // Track the last selected node for animations

        // Define panel-related constants and functions early for broad access
        const assetsPanel = document.getElementById('assetsPanel');
        const assetsPanelToggle = document.getElementById('assetsPanelToggle');

        /**
         * Opens the assets panel if it's currently closed, allowing users to see newly added media.
         */
        function openAssetsPanel() {
            if (!assetsPanel.classList.contains('expanded')) {
                assetsPanel.classList.add('expanded');
                assetsPanelToggle.innerHTML = '▶';
                assetsPanelToggle.title = 'Collapse Media Library';
                // Resize stage after the panel has had a moment to animate open
                setTimeout(resizeStage, 300); 
            }
        }

        // Utility functions
        function showLoading() {
            document.getElementById('loadingIndicator').style.display = 'block';
        }

        function hideLoading() {
            document.getElementById('loadingIndicator').style.display = 'none';
        }

        function showFolderLoading(current, total) {
            const indicator = document.getElementById('folderLoadingIndicator');
            const countEl = document.getElementById('folderLoadingCount');
            const totalEl = document.getElementById('folderLoadingTotal');
            const progressBar = document.getElementById('folderLoadingProgress');
            indicator.style.display = 'block';
            countEl.textContent = current;
            totalEl.textContent = total;
            const percentage = total > 0 ? (current / total) * 100 : 0;
            progressBar.style.width = percentage + '%';
        }

        function hideFolderLoading() {
            document.getElementById('folderLoadingIndicator').style.display = 'none';
        }

        function showShortcutFeedback(message) {
            // Create or update feedback element
            let feedback = document.getElementById('shortcutFeedback');
            if (!feedback) {
                feedback = document.createElement('div');
                feedback.id = 'shortcutFeedback';
                feedback.style.cssText = `
                    position: fixed;
                    top: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(52, 199, 89, 0.9);
                    color: white;
                    padding: 8px 16px;
                    border-radius: 6px;
                    font-size: 12px;
                    font-weight: 600;
                    z-index: 2001;
                    opacity: 0;
                    transition: opacity 0.3s ease;
                    pointer-events: none;
                `;
                document.body.appendChild(feedback);
            }
            feedback.textContent = message;
            feedback.style.opacity = '1';
            // Clear any existing timeout
            if (feedback.hideTimeout) {
                clearTimeout(feedback.hideTimeout);
            }
            // Hide after 1.5 seconds
            feedback.hideTimeout = setTimeout(() => {
                feedback.style.opacity = '0';
            }, 1500);
        }

        function showError(message) {
            const errorEl = document.getElementById('errorMessage');
            errorEl.textContent = message;
            errorEl.style.display = 'block';
            setTimeout(() => {
                errorEl.style.display = 'none';
            }, 3000);
        }

        function updateActiveElement(node) {
            if (!layer || !transformer) return;

            try {
                if (node && node.name() === 'background_image') {
                    // If the selected node is the background image
                    transformer.nodes([node]);
                    transformer.moveToTop(); // Ensure transformer is on top
                    transformer.borderStroke('#FFFF00'); // Yellow border for background
                    transformer.anchorStroke('#FFFF00'); // Yellow anchors
                    transformer.anchorFill('#FFFF00');
                    lastSelectedNode = node; // Track last selected node
                } else if (node) {
                    // If the selected node is a regular media element
                    transformer.nodes([node]);
                    transformer.moveToTop(); // Ensure transformer is on top
                    // Reset transformer color to default green
                    transformer.borderStroke('#34c759');
                    transformer.anchorStroke('#34c759');
                    transformer.anchorFill('#34c759');
                    lastSelectedNode = node; // Track last selected node
                } else {
                    // If no node is selected, clear transformer and reset color
                    transformer.nodes([]);
                    transformer.borderStroke('#34c759');
                    transformer.anchorStroke('#34c759');
                    transformer.anchorFill('#34c759');
                    // Don't clear lastSelectedNode when deselecting
                }
                layer.draw(); // Draw the main layer which contains the transformer
            }
            catch (e) {
                console.error('Error updating active element:', e);
            }
        }

        // Helper function to get the target node for animations
        function getTargetNode() {
            const currentlySelected = transformer.nodes()[0];
            const target = currentlySelected || lastSelectedNode;
            console.log('getTargetNode called - currently selected:', currentlySelected, 'last selected:', lastSelectedNode, 'returning:', target);
            return target;
        }

        function validateFile(file) {
            const maxSize = 50 * 1024 * 1024; // 50MB limit
            const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'video/mp4', 'video/webm', 'video/ogg'];
            if (file.size > maxSize) {
                showError(`File "${file.name}" is too large. Maximum size is 50MB.`);
                return false;
            }
            if (!allowedTypes.includes(file.type)) {
                // For folder uploads, we might encounter other file types, just skip them silently
                return false;
            }
            return true;
        }

        // Helper to load an image and return an Image object
        function loadImageElement(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = (e) => reject(new Error(`Failed to load image element from ${src}: ${e.message}`));
                img.src = src;
            });
        }

        // Helper to create and prepare a video element
        function createVideoElement(src) {
            return new Promise((resolve, reject) => {
                const videoElement = document.createElement('video');
                videoElement.src = src;
                videoElement.loop = true;
                videoElement.muted = true;
                videoElement.setAttribute('webkit-playsinline', 'webkit-playsinline');
                videoElement.setAttribute('playsinline', 'playsinline');
                videoElement.style.display = 'none'; // Keep it hidden from direct DOM
                
                // Append to body immediately so it can start loading/playing
                document.body.appendChild(videoElement);

                // Wait for metadata to be loaded before considering it "ready" for Konva
                videoElement.onloadedmetadata = () => {
                    // Once metadata is loaded, Konva can use it.
                    // Start playing immediately if possible.
                    videoElement.play().catch(e => console.warn("Video autoplay prevented:", e));
                    resolve(videoElement);
                };
                videoElement.onerror = (e) => {
                    console.error("Video element loading error:", e);
                    reject(new Error(`Failed to load video element from ${src}`));
                };
            });
        }

        // --- GLOBAL FUNCTIONS FOR EVENT LISTENERS ---

        /**
         * Handles files selected from the file input (single or multiple).
         * @param {FileList} files - The FileList object from the input.
         */
        async function handleFiles(files) {
            if (!files || files.length === 0) return;
            for (const file of Array.from(files)) {
                if (!validateFile(file)) continue;
                showLoading(); // Show loading for each file
                try {
                    const dataUrl = await new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = (e) => resolve(e.target.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(file);
                    });
                    const uniqueId = `${file.type.split('/')[0]}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

                    if (file.type.startsWith('image/')) {
                        const img = await loadImageElement(dataUrl); // Use new helper
                        addToAssetsPanel(img, uniqueId, file.type.includes('gif') ? 'gif' : 'image');
                    } else if (file.type.startsWith('video/')) {
                        const videoElement = await createVideoElement(dataUrl); // Use new helper
                        addToAssetsPanel(videoElement, uniqueId, 'video'); 
                    }
                    hideLoading(); // Hide after successful processing of *this* file
                } catch (error) {
                    hideLoading();
                    showError(`Failed to load "${file.name}": ${error.message}`);
                }
            }
        }

        /**
         * Handles files selected from a folder input.
         * @param {FileList} files - The FileList object from the input.
         */
        async function handleFolderFiles(files) {
            if (!files || files.length === 0) {
                showError('No files selected in folder.');
                return;
            }

            const validFiles = Array.from(files).filter(validateFile);
            if (validFiles.length === 0) {
                showError('No valid image or video files found in the selected folder.');
                hideFolderLoading();
                return;
            }

            let loadedCount = 0;
            showFolderLoading(loadedCount, validFiles.length);

            for (const file of validFiles) {
                try {
                    const dataUrl = await new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = (e) => resolve(e.target.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(file);
                    });
                    const uniqueId = `${file.type.split('/')[0]}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

                    if (file.type.startsWith('image/')) {
                        const img = await loadImageElement(dataUrl); // Use new helper
                        addToAssetsPanel(img, uniqueId, file.type.includes('gif') ? 'gif' : 'image');
                    } else if (file.type.startsWith('video/')) {
                        const videoElement = await createVideoElement(dataUrl); // Use new helper
                        addToAssetsPanel(videoElement, uniqueId, 'video');
                    }
                } catch (error) {
                    console.error('Error processing file from folder:', file.name, error);
                    showError(`Failed to load "${file.name}" from folder.`);
                } finally {
                    loadedCount++;
                    showFolderLoading(loadedCount, validFiles.length);
                }
            }
            hideFolderLoading();
        }

        /**
         * Handles a background image file selected from the input.
         * @param {FileList} files - The FileList object from the input.
         */
        function handleBackgroundImage(files) {
            if (!files || files.length === 0) return;
            const file = files[0];
            if (!file.type.startsWith('image/')) {
                showError('Please select an image file for the background.');
                return;
            }

            showLoading();
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    hideLoading();
                    const uniqueId = 'bg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    addToBackgroundAssetsPanel(img, uniqueId, 'background'); // Add to background assets panel
                    // No direct drawing here, it's dragged from the panel now
                };
                img.onerror = function() {
                    hideLoading();
                    showError('Failed to load background image.');
                };
                img.src = e.target.result;
            };
            reader.onerror = function() {
                hideLoading();
                showError('Failed to read background image file.');
            };
            reader.readAsDataURL(file);
        }

        // --- KONVA DRAWING FUNCTIONS ---

        /**
         * Draws a background image on the dedicated background layer.
         * @param {HTMLImageElement} img - The loaded Image element.
         * @param {string} uniqueId - A unique ID for the Konva node.
         */
        function drawBackground(img, uniqueId) {
            backgroundLayer.destroyChildren(); // Clear existing background

            const stageWidth = stage.width();
            const stageHeight = stage.height();

            // Calculate scale to make the lesser dimension fill the screen, maintaining aspect ratio
            const scaleX = stageWidth / img.width;
            const scaleY = stageHeight / img.height;
            const scale = Math.max(scaleX, scaleY); // Use Math.max to ensure the image covers the canvas

            const newWidth = img.width * scale;
            const newHeight = img.height * scale;

            // Center the image (it might overflow)
            const x = (stageWidth - newWidth) / 2;
            const y = (stageHeight - newHeight) / 2;

            const backgroundImage = new Konva.Image({
                image: img,
                x: x,
                y: y,
                width: newWidth,
                height: newHeight,
                listening: true, // Make background interactive
                name: 'background_image', // Name to easily identify background
                id: uniqueId // Assign a unique ID
            });

            // Add event listener for clicking the background image
            backgroundImage.on('click tap', () => updateActiveElement(backgroundImage));
            backgroundImage.on('transformend', () => {
                // Recalculate size/position if transformed (though it shouldn't be directly transformable in practice)
                resizeStage(); // This should handle the scaling logic
                layer.draw();
            });

            backgroundLayer.add(backgroundImage);
            backgroundLayer.draw();

            // Store reference to the current background node
            currentBackgroundNode = backgroundImage;
            
            // Add to mediaElements for consistent management (especially deletion)
            mediaElements.set(backgroundImage.id(), backgroundImage);

            // After drawing, select it to show its bounding box
            updateActiveElement(backgroundImage);
        }

        /**
         * Draws a static image on the main layer.
         * @param {HTMLImageElement} image - The loaded Image element.
         * @param {number} x - X coordinate for the center of the image.
         * @param {number} y - Y coordinate for the center of the image.
         * @param {string} uniqueId - A unique ID for the Konva node.
         */
        function drawImage(image, x, y, uniqueId) { 
5            // Get available canvas dimensions and center coordinates
            const maxWidth = stage.width() * 0.9; // 90% of canvas width
            const maxHeight = stage.height() * 0.9; // 90% of canvas height
            const centerX = stage.width() / 2;
            const centerY = stage.height() / 2;
            
            // Calculate scale to fit within canvas bounds while maintaining aspect ratio
            const scaleX = maxWidth / image.width;
            const scaleY = maxHeight / image.height;
            const scale = Math.min(scaleX, scaleY, 1); // Don't scale up, only down if needed
            
            const finalWidth = image.width * scale;
            const finalHeight = image.height * scale;

            const konvaImage = new Konva.Image({
                image: image,
                x: centerX - finalWidth / 2,
                y: centerY - finalHeight / 2,
                width: finalWidth,
                height: finalHeight,
                draggable: true,
                id: uniqueId, // Explicitly set the ID
            });
            layer.add(konvaImage);
            konvaImage.on('click tap', () => updateActiveElement(konvaImage));
            konvaImage.on('transformend', () => layer.draw());
            mediaElements.set(konvaImage.id(), konvaImage); // Use konvaImage.id()
            layer.draw();
            updateActiveElement(konvaImage);
            return konvaImage;
        }

        /**
         * Draws an animated GIF on the main layer.
         * @param {HTMLImageElement} image - The initial loaded Image element.
         * @param {number} x - X coordinate for the center of the GIF.
         * @param {number} y - Y coordinate for the center of the GIF.
         * @param {string} src - The data URL of the GIF.
         * @param {string} uniqueId - A unique ID for the Konva node.
         */
        function drawAnimatedGif(image, x, y, src, uniqueId) {
            // Use an invisible img tag to decode the GIF frames
            const gifImageElement = document.createElement('img');
            gifImageElement.src = src;
            gifImageElement.style.position = 'absolute';
            gifImageElement.style.left = '-9999px';
            gifImageElement.style.top = '-9999px';
            gifImageElement.style.visibility = 'hidden';
            gifImageElement.style.pointerEvents = 'none'; // Corrected property name from pointer-events
            document.getElementById('gif-container').appendChild(gifImageElement);

            gifler(src).frames(function (frames, ctrl) {
                // Get available canvas dimensions and center coordinates
                const maxWidth = stage.width() * 0.9; // 90% of canvas width
                const maxHeight = stage.height() * 0.9; // 90% of canvas height
                const centerX = stage.width() / 2;
                const centerY = stage.height() / 2;
                
                // Calculate scale to fit within canvas bounds while maintaining aspect ratio
                const scaleX = maxWidth / frames[0].image.width;
                const scaleY = maxHeight / frames[0].image.height;
                const scale = Math.min(scaleX, scaleY, 1); // Don't scale up, only down if needed
                
                const finalWidth = frames[0].image.width * scale;
                const finalHeight = frames[0].image.height * scale;

                const konvaGif = new Konva.Image({
                    image: frames[0].image,
                    x: centerX - finalWidth / 2,
                    y: centerY - finalHeight / 2,
                    width: finalWidth,
                    height: finalHeight,
                    draggable: true,
                    id: uniqueId, // Explicitly set the ID
                    // Store reference to gifler control to stop/start animation
                    gifCtrl: ctrl
                });

                layer.add(konvaGif);
                konvaGif.on('click tap', () => updateActiveElement(konvaGif));
                konvaGif.on('transformend', () => layer.draw());
                mediaElements.set(konvaGif.id(), konvaGif); // Use konvaGif.id()
                layer.draw();
                updateActiveElement(konvaGif);

                activeGifAnimations.set(konvaGif.id(), ctrl); // Store the gifler control using konvaGif.id()

                let frameIndex = 0;
                const animateGif = () => {
                    const frame = frames[frameIndex];
                    konvaGif.image(frame.image);
                    layer.draw();

                    frameIndex = (frameIndex + 1) % frames.length;
                    konvaGif.gifAnimationId = setTimeout(animateGif, frame.delay);
                };
                konvaGif.gifAnimationId = setTimeout(animateGif, frames[0].delay);
            });
        }

        /**
         * Draws a video on the main layer.
         * @param {HTMLVideoElement} videoElement - The prepared HTMLVideoElement.
         * @param {number} x - X coordinate for the center of the video.
         * @param {number} y - Y coordinate for the center of the video.
         * @param {string} uniqueId - A unique ID for the Konva node.
         */
        function drawVideo(videoElement, x, y, uniqueId) { 
            // Get available canvas dimensions and center coordinates
            const maxWidth = stage.width() * 0.9; // 90% of canvas width
            const maxHeight = stage.height() * 0.9; // 90% of canvas height
            const centerX = stage.width() / 2;
            const centerY = stage.height() / 2;

            // Calculate aspect ratio and constrain to canvas bounds
            const aspectRatio = videoElement.videoWidth / videoElement.videoHeight;
            
            let width = videoElement.videoWidth;
            let height = videoElement.videoHeight;

            // Scale down if video is larger than available space
            if (width > maxWidth) {
                width = maxWidth;
                height = maxWidth / aspectRatio;
            }
            if (height > maxHeight) {
                height = maxHeight;
                width = maxHeight * aspectRatio;
            }

            const konvaVideo = new Konva.Image({
                image: videoElement, // Direct use of the HTMLVideoElement
                x: centerX - width / 2,
                y: centerY - height / 2,
                width: width,
                height: height,
                draggable: true,
                stroke: 'white',
                strokeWidth: 2,
                id: uniqueId,
            });

            layer.add(konvaVideo);
            konvaVideo.on('click tap', () => updateActiveElement(konvaVideo));
            konvaVideo.on('transformend', () => layer.draw());
            mediaElements.set(konvaVideo.id(), konvaVideo);
            layer.draw();
            updateActiveElement(konvaVideo);

            // Add a simple animation to update the Konva.Image
            // This animation is not strictly necessary for display but can help
            // Konva update the video frames if it needs to.
            const videoAnimation = new Konva.Animation(() => {
                // No explicit drawing needed here, Konva internally updates video frames
            }, layer);
            activeAnimations.set(konvaVideo.id(), videoAnimation);
            videoAnimation.start();
        }

        /**
         * Adds a text node to the main layer.
         * @param {string} text - The text content.
         * @param {number} x - X coordinate for the center of the text.
         * @param {number} y - Y coordinate for the center of the text.
         * @param {number} fontSize - Font size in pixels.
         * @param {string} fill - Text color.
         * @param {string} fontFamily - Font family name.
         * @param {string} uniqueId - A unique ID for the Konva node.
         */
        function addTextNode(text = 'New Text', x, y, fontSize = 24, fill = '#ffffff', fontFamily = 'Arial', uniqueId = 'text_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9)) {
            const textNode = new Konva.Text({
                text: text,
                x: x,
                y: y,
                fontSize: fontSize,
                fontFamily: fontFamily,
                fill: fill,
                draggable: true,
                width: 200, // Initial width for wrapping
                padding: 10,
                align: 'center',
                id: uniqueId, // Explicitly set the ID
            });

            layer.add(textNode);
            textNode.on('click tap', () => updateActiveElement(textNode));
            textNode.on('transformend', () => {
                textNode.width(textNode.width() * textNode.scaleX());
                textNode.height(textNode.height() * textNode.scaleY());
                textNode.scaleX(1);
                textNode.scaleY(1);
                layer.draw();
            });
            mediaElements.set(textNode.id(), textNode); // Use textNode.id()
            layer.draw();
            updateActiveElement(textNode);
            return textNode;
        }

        // --- ASSET PANEL MANAGEMENT FUNCTIONS ---

        /**
         * Adds an asset thumbnail to the main assets panel.
         * @param {HTMLImageElement|HTMLVideoElement} asset - The loaded Image or Video element.
         * @param {string} id - The unique ID of the asset.
         * @param {string} type - The type of asset ('image', 'gif', 'video').
         */
        function addToAssetsPanel(asset, id, type) {
            const assetsList = document.getElementById('assetsList');
            const assetContainer = document.createElement('div');
            assetContainer.className = 'asset-container';
            assetContainer.draggable = true;
            assetContainer.dataset.assetId = id;
            assetContainer.dataset.assetType = type;

            let thumbnailSrc;
            if (type === 'image' || type === 'gif') {
                thumbnailSrc = asset.src;
            } else if (type === 'video') {
                // For video, we'll create a canvas thumbnail
                const canvas = document.createElement('canvas');
                canvas.width = 160; // Fixed width for thumbnail
                canvas.height = 90; // Fixed height for thumbnail
                const ctx = canvas.getContext('2d');
                ctx.drawImage(asset, 0, 0, canvas.width, canvas.height);
                thumbnailSrc = canvas.toDataURL('image/png');
            }

            const thumbnail = document.createElement('img');
            thumbnail.src = thumbnailSrc;
            thumbnail.alt = `Asset Thumbnail ${id}`;
            thumbnail.className = 'asset-thumbnail';
            assetContainer.appendChild(thumbnail);

            if (type === 'gif') {
                const gifIndicator = document.createElement('span');
                gifIndicator.className = 'gif-indicator';
                gifIndicator.textContent = 'GIF';
                assetContainer.appendChild(gifIndicator);
            } else if (type === 'video') {
                const videoIndicator = document.createElement('span');
                videoIndicator.className = 'gif-indicator'; // Reuse styling, rename class if needed
                videoIndicator.textContent = 'VIDEO';
                videoIndicator.style.backgroundColor = '#007bff'; // Blue for video
                assetContainer.appendChild(videoIndicator);
            }

            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'asset-delete-btn';
            deleteBtn.innerHTML = '&times;';
            deleteBtn.onclick = (e) => {
                e.stopPropagation();
                // When deleting from the asset panel, we want to remove it completely
                deleteAsset(id, assetContainer, false); // Pass assetContainer so it's removed from panel
            };
            assetContainer.appendChild(deleteBtn);

            assetsList.appendChild(assetContainer);
            // Store the actual asset object for dragging
            assetCache.set(id, { asset, type, src: asset.src }); 
            openAssetsPanel(); // Open panel to show the newly added asset
        }

        /**
         * Adds a background asset thumbnail to the background assets panel.
         * @param {HTMLImageElement} asset - The loaded Image element.
         * @param {string} id - The unique ID of the asset.
         * @param {string} type - The type of asset ('background').
         */
        function addToBackgroundAssetsPanel(asset, id, type) {
            const backgroundAssetsList = document.getElementById('backgroundAssetsList');
            const assetContainer = document.createElement('div');
            assetContainer.className = 'asset-container';
            assetContainer.draggable = true;
            assetContainer.dataset.assetId = id;
            assetContainer.dataset.assetType = type;

            const thumbnail = document.createElement('img');
            thumbnail.src = asset.src;
            thumbnail.alt = `Background Thumbnail ${id}`;
            thumbnail.className = 'asset-thumbnail';
            assetContainer.appendChild(thumbnail);

            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'asset-delete-btn';
            deleteBtn.innerHTML = '&times;';
            deleteBtn.onclick = (e) => {
                e.stopPropagation();
                // Backgrounds are always fully removed when deleted from the panel.
                deleteAsset(id, assetContainer, true); // Pass true to indicate it's a background asset
            };
            assetContainer.appendChild(deleteBtn);

            backgroundAssetsList.appendChild(assetContainer);
            assetCache.set(id, { asset, type, src: asset.src }); // Cache background asset
            openAssetsPanel(); // Open panel to show the newly added asset
        }

        /**
         * Deletes an asset from the canvas and/or asset panel/cache.
         * @param {string} id - The unique ID of the asset.
         * @param {HTMLElement|null} element - The HTML element of the asset container in the panel, if deletion originated there.
         * @param {boolean} isBackground - True if it's a background image.
         */
        function deleteAsset(id, element = null, isBackground = false) {
            // In a real application, you'd use a custom modal here
            const userConfirmed = true; 

            if (userConfirmed) {
                // Handle deletion of Konva node from the canvas for both background and regular assets
                let konvaNodeToRemove = null;
                if (isBackground) {
                    if (currentBackgroundNode && currentBackgroundNode.id() === id) {
                        konvaNodeToRemove = currentBackgroundNode;
                        currentBackgroundNode = null; // Clear the background reference
                    }
                } else {
                    konvaNodeToRemove = layer.find(node => node.id() === id)[0];
                }

                if (konvaNodeToRemove) {
                    // Stop animations associated with the node
                    if (activeGifAnimations.has(konvaNodeToRemove.id())) {
                        clearTimeout(konvaNodeToRemove.gifAnimationId); 
                        activeGifAnimations.delete(konvaNodeToRemove.id());
                    }
                    if (activeAnimations.has(konvaNodeToRemove.id())) {
                        activeAnimations.get(konvaNodeToRemove.id()).stop();
                        activeAnimations.delete(konvaNodeToRemove.id());
                    }
                    // If it's a video element, remove its HTML video tag from the DOM
                    if (konvaNodeToRemove.image() && konvaNodeToRemove.image().tagName === 'VIDEO') {
                         konvaNodeToRemove.image().remove();
                    }

                    // Destroy the Konva node
                    konvaNodeToRemove.destroy();
                    if (transformer.nodes().includes(konvaNodeToRemove)) {
                        transformer.nodes([]); // Deselect if currently selected
                    }
                    mediaElements.delete(konvaNodeToRemove.id()); // Remove from active media elements map
                    layer.draw(); // Redraw main layer
                    if (isBackground) {
                        backgroundLayer.draw(); // Redraw background layer if needed
                    }
                    showShortcutFeedback('Item deleted from canvas');
                } else {
                    console.log('Konva node not found on canvas or already deleted:', id);
                }

                // Handle removal from asset panel and cache
                // If 'element' is provided, it means deletion originated from the asset panel's 'X' button
                if (element) {
                    element.remove(); // Remove the thumbnail from the UI
                    assetCache.delete(id); // Remove from cache
                    showShortcutFeedback('Item removed from library');
                }
                // If element is null (deletion was from canvas), the item remains in assetCache and asset panel.
                // This applies to both regular assets and backgrounds as per the user's request.
            } else {
                console.log('Deletion cancelled by user.');
                       }
        }

        // --- KONVA DRAG & DROP EVENT LISTENERS ---

        document.getElementById('assetsList').addEventListener('dragstart', (e) => {
            if (e.target.classList.contains('asset-thumbnail')) {
                const assetContainer = e.target.closest('.asset-container');
                if (assetContainer) {
                    e.dataTransfer.setData('text/plain', assetContainer.dataset.assetId);
                    e.dataTransfer.effectAllowed = 'copy';
                }
            }
        });

        document.getElementById('backgroundAssetsList').addEventListener('dragstart', (e) => {
            if (e.target.classList.contains('asset-thumbnail')) {
                const assetContainer = e.target.closest('.asset-container');
                if (assetContainer) {
                    e.dataTransfer.setData('text/plain', assetContainer.dataset.assetId);

                    e.dataTransfer.effectAllowed = 'copy';
                }
            }
        });

        document.getElementById('container').addEventListener('dragover', (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
            document.getElementById('container').classList.add('drag-over');
        });

        document.getElementById('container').addEventListener('dragleave', (e) => {
            document.getElementById('container').classList.remove('drag-over');
        });

        document.getElementById('container').addEventListener('drop', async (e) => {
            e.preventDefault();
            document.getElementById('container').classList.remove('drag-over');

            const assetId = e.dataTransfer.getData('text/plain');
            if (!assetId) return;

            const assetData = assetCache.get(assetId);
            if (!assetData) {
                showError('Asset not found in cache.');
                return;
            }

            const pointerPosition = stage.getPointerPosition();
            const dropX = pointerPosition.x;
            const dropY = pointerPosition.y;

            showLoading();
            try {
                if (assetData.type === 'image') {
                    const img = await loadImageElement(assetData.src); // Use helper
                    hideLoading();
                    drawImage(img, dropX, dropY, assetId); // Pass assetId
                } else if (assetData.type === 'gif') {
                    const img = await loadImageElement(assetData.src); // Use helper
                    hideLoading();
                    drawAnimatedGif(img, dropX, dropY, assetData.src, assetId); // Pass assetId
                } else if (assetData.type === 'video') {
                    // Re-use the existing video element from cache for performance, don't create new
                    const videoElement = assetData.asset; 
                    hideLoading();
                    drawVideo(videoElement, dropX, dropY, assetId); // Pass assetId
                } else if (assetData.type === 'text') {
                     // For text, add a new text node with default properties or from cached data
                    addTextNode(assetData.text || 'Dragged Text', dropX, dropY, assetData.fontSize, assetData.fill, assetData.fontFamily, assetId); // Pass assetId
                    hideLoading();
                } else if (assetData.type === 'background') { // Handle background image drop
                    const img = await loadImageElement(assetData.src); // Use helper
                    hideLoading();
                    drawBackground(img, assetId); // Pass assetId to drawBackground
                    showShortcutFeedback('Background image set');
                }
            } catch (error) {
                hideLoading();
                showError('Error dropping asset: ' + error.message);
            }
        });

        // --- UI AND HOTKEY EVENT LISTENERS ---

        // Fullscreen toggle
        document.getElementById('fullscreenToggle').addEventListener('click', async () => {
            try {
                if (document.fullscreenElement) {
                    await document.exitFullscreen();
                } else {
                    await document.documentElement.requestFullscreen();
                }
            } catch (e) {
                console.error("Fullscreen error:", e);
                showError("Fullscreen functionality is blocked by browser or permissions policy.");
            }
        });

        document.addEventListener('fullscreenchange', () => {
            const button = document.getElementById('fullscreenToggle');
            // Keep the same icon, only change title for consistency
            button.innerHTML = '⛶'; 
            button.title = document.fullscreenElement ? 'Exit Fullscreen - Press F11' : 'Toggle Fullscreen - Press F11';
        });

        // Hotkeys for toolbar actions
        document.addEventListener('keydown', (e) => {
            // Get the currently selected node from the transformer or last selected
            let selectedNode = getTargetNode();

            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (selectedNode) {
                    // Determine if it's the background or a regular element
                    if (selectedNode.name() === 'background_image') {
                        // Call deleteAsset for background, but don't remove from panel/cache if deleted from canvas
                        deleteAsset(selectedNode.id(), null, true); // Pass null for element, true for isBackground
                    } else {
                        // Call deleteAsset for regular media, but don't remove from panel/cache if deleted from canvas
                        deleteAsset(selectedNode.id(), null, false); // Pass null for element, false for isBackground
                    }
                    // Clear the last selected node if we just deleted it
                    if (lastSelectedNode === selectedNode) {
                        lastSelectedNode = null;
                    }
                    e.preventDefault(); // Prevent browser back navigation
                } else {
                    showError('Select an item first or no previous selection found.');
                }
            }

            if (e.ctrlKey && e.key === '1') { // Ctrl + 1 for Shake
                e.preventDefault();
                document.getElementById('shakeButton').click();
            }
            if (e.ctrlKey && e.key === '2') { // Ctrl + 2 for Circle
                e.preventDefault();
                document.getElementById('circleButton').click();
            }
            if (e.ctrlKey && e.key === '3') { // Ctrl + 3 for Animation Settings
                e.preventDefault();
                document.getElementById('animationSettings').click();
            }
            if (e.ctrlKey && e.key === '4') { // Ctrl + 4 for Flip
                e.preventDefault();
                document.getElementById('flipButton').click();
            }
            if (e.ctrlKey && e.key === 'ArrowUp') { // Ctrl + Up Arrow for Move Layer Up
                e.preventDefault();
                document.getElementById('moveUp').click();
            }
            if (e.ctrlKey && e.key === 'ArrowDown') { // Ctrl + Down Arrow for Move Layer Down
                e.preventDefault();
                document.getElementById('moveDown').click();
            }
            if (e.key === 'F11') { // F11 for Fullscreen
                e.preventDefault();
                document.getElementById('fullscreenToggle').click();
            }
        });

        // Implement toolbar functionality
        document.getElementById('increaseSize').addEventListener('click', () => {
            const node = getTargetNode();
            if (node) {
                node.scaleX(node.scaleX() * 1.1);
                node.scaleY(node.scaleY() * 1.1);
                layer.draw();
                showShortcutFeedback('Increased Size');
            } else {
                showError('Select an item first or no previous selection found.');
            }
        });

        document.getElementById('decreaseSize').addEventListener('click', () => {
            const node = getTargetNode();
            if (node) {
                node.scaleX(node.scaleX() * 0.9);
                node.scaleY(node.scaleY() * 0.9);
                layer.draw();
                showShortcutFeedback('Decreased Size');
            } else {
                showError('Select an item first or no previous selection found.');
            }
        });

        document.getElementById('deleteItem').addEventListener('click', () => {
            const node = getTargetNode();
            if (node) {
                // Determine if it's the background or a regular element
                if (node.name() === 'background_image') {
                    // Call deleteAsset for background, but don't remove from panel/cache if deleted from canvas
                    deleteAsset(node.id(), null, true); // Pass null for element, true for isBackground
                } else {
                    // Call deleteAsset for regular media, but don't remove from panel/cache if deleted from canvas
                    deleteAsset(node.id(), null, false); // Pass null for element, false for isBackground
                }
                // Clear the last selected node if we just deleted it
                if (lastSelectedNode === node) {
                    lastSelectedNode = null;
                }
            } else {
                showError('Select an item first or no previous selection found.');
            }
        });

        // Layer control functions
        document.getElementById('moveUp').addEventListener('click', () => {
            const node = getTargetNode();
            if (node) {
                // Don't allow moving background elements
                if (node.name() === 'background_image') {
                    showError('Background images cannot be moved in layers.');
                    return;
                }
                node.moveUp();
                layer.draw();
                showShortcutFeedback('Moved layer up');
            } else {
                showError('Select an item first or no previous selection found.');
            }
        });

        document.getElementById('moveDown').addEventListener('click', () => {
            const node = getTargetNode();
            if (node) {
                // Don't allow moving background elements
                if (node.name() === 'background_image') {
                    showError('Background images cannot be moved in layers.');
                    return;
                }
                node.moveDown();
                layer.draw();
                showShortcutFeedback('Moved layer down');
            } else {
                showError('Select an item first or no previous selection found.');
            }
        });

        document.getElementById('shakeButton').addEventListener('click', () => {
            const node = getTargetNode();
            console.log('Shake button clicked, target node:', node); // Debug log
            if (node) {
                // Stop any existing animation on this node
                if (activeAnimations.has(node.id())) {
                    activeAnimations.get(node.id()).stop();
                    activeAnimations.delete(node.id());
                }
                
                const initialX = node.x();
                const amplitude = shakeSettings.distance / 2;
                const duration = 2000 / shakeSettings.speed; // Total duration in milliseconds
                let startTime = null;

                const shakeAnimation = new Konva.Animation(function (frame) {
                    if (!startTime) startTime = frame.time;
                    const elapsed = frame.time - startTime;
                    
                    // Stop animation when duration is reached
                    if (elapsed >= duration) {
                        node.x(initialX); // Reset to initial position
                        shakeAnimation.stop();
                        activeAnimations.delete(node.id());
                        layer.draw();
                        return;
                    }

                    // Calculate shake position
                    const progress = elapsed / duration;
                    const cycles = shakeSettings.repetitions;
                    const newX = initialX + amplitude * Math.sin(progress * cycles * Math.PI * 2);
                    node.x(newX);
                }, layer);

                activeAnimations.set(node.id(), shakeAnimation);
                shakeAnimation.start();
                showShortcutFeedback('Shake Animation applied');
            } else {
                showError('Select an item first or no previous selection found.');
            }
        });

        document.getElementById('circleButton').addEventListener('click', () => {
            const node = getTargetNode();
            console.log('Circle button clicked, target node:', node); // Debug log
            if (node) {
                // Stop any existing animation on this node
                if (activeAnimations.has(node.id())) {
                    activeAnimations.get(node.id()).stop();
                    activeAnimations.delete(node.id());
                }
                
                const initialX = node.x();
                const initialY = node.y();
                const centerX = initialX + node.width() / 2;
                const centerY = initialY + node.height() / 2;
                const radius = circleSettings.radius;
                const duration = 3000 / circleSettings.speed; // Total duration in milliseconds
                let startTime = null;

                const circleAnimation = new Konva.Animation(function (frame) {
                    if (!startTime) startTime = frame.time;
                    const elapsed = frame.time - startTime;
                    
                    // Stop animation when duration is reached
                    if (elapsed >= duration) {
                        node.x(initialX); // Reset to initial position
                        node.y(initialY);
                        circleAnimation.stop();
                        activeAnimations.delete(node.id());
                        layer.draw();
                        return;
                    }

                    // Calculate circle position
                    const progress = elapsed / duration;
                    const cycles = circleSettings.repetitions;
                    const angle = progress * cycles * Math.PI * 2;
                    node.x(centerX + radius * Math.cos(angle) - node.width() / 2);
                    node.y(centerY + radius * Math.sin(angle) - node.height() / 2);
                }, layer);

                activeAnimations.set(node.id(), circleAnimation);
                circleAnimation.start();
                showShortcutFeedback('Circle Animation applied');
            } else {
                showError('Select an item first or no previous selection found.');
            }
        });

        document.getElementById('flipButton').addEventListener('click', () => {
            const node = getTargetNode();
            console.log('Flip button clicked, target node:', node); // Debug log
            if (node) {
                // Stop any existing animation on this node
                if (activeAnimations.has(node.id())) {
                    activeAnimations.get(node.id()).stop();
                    activeAnimations.delete(node.id());
                }
                
                // Always start from the CURRENT state of the node
                const startScaleX = node.scaleX();
                const targetScaleX = -startScaleX; // Simply flip to the opposite
                
                // Calculate the current center of the object
                const centerX = node.x() + (node.width() * startScaleX) / 2;
                const centerY = node.y() + node.height() / 2;
                
                const duration = 1000 / flipSettings.speed; // Duration for the flip
                let startTime = null;

                const flipAnimation = new Konva.Animation(function (frame) {
                    if (!startTime) startTime = frame.time;
                    const elapsed = frame.time - startTime;
                    
                    // Stop animation when duration is reached
                    if (elapsed >= duration) {
                        node.scaleX(targetScaleX);
                        // Position so center remains at centerX
                        node.x(centerX - (node.width() * targetScaleX) / 2);
                        node.y(centerY - node.height() / 2);
                        flipAnimation.stop();
                        activeAnimations.delete(node.id());
                        layer.draw();
                        return;
                    }

                    // Calculate smooth progress from 0 to 1
                    const progress = elapsed / duration;
                    
                    // Use cosine for smooth flip motion (goes from 1 to -1)
                    const scaleProgress = Math.cos(progress * Math.PI);
                    
                    // Interpolate between start and target scale
                    const currentScaleX = startScaleX + (targetScaleX - startScaleX) * (1 - scaleProgress) / 2;
                    
                    node.scaleX(currentScaleX);
                    // Keep the center fixed
                    node.x(centerX - (node.width() * currentScaleX) / 2);
                    node.y(centerY - node.height() / 2);
                }, layer);

                activeAnimations.set(node.id(), flipAnimation);
                flipAnimation.start();
                showShortcutFeedback('Flip Animation applied');
            } else {
                showError('Select an item first or no previous selection found.');
            }
        });

        // Animation Settings Menu
        const animationSettingsMenu = document.getElementById('animationSettingsMenu');
        const shakeSpeedSlider = document.getElementById('shakeSpeed');
        const shakeSpeedValueDisplay = document.getElementById('shakeSpeedValue');
        const shakeRepetitionsInput = document.getElementById('shakeRepetitions');
        const shakeDistanceSlider = document.getElementById('shakeDistance');
        const shakeDistanceValueDisplay = document.getElementById('shakeDistanceValue');

        const circleSpeedSlider = document.getElementById('circleSpeed');
        const circleSpeedValueDisplay = document.getElementById('circleSpeedValue');
        const circleRepetitionsInput = document.getElementById('circleRepetitions');
        const circleRadiusSlider = document.getElementById('circleRadius');
        const circleRadiusValueDisplay = document.getElementById('circleRadiusValue');

        const flipSpeedSlider = document.getElementById('flipSpeed');
        const flipSpeedValueDisplay = document.getElementById('flipSpeedValue');
        const flipRepetitionsInput = document.getElementById('flipRepetitions');

        document.getElementById('animationSettings').addEventListener('click', () => {
            // Load current settings into the sliders
            shakeSpeedSlider.value = shakeSettings.speed;
            shakeSpeedValueDisplay.textContent = `${shakeSettings.speed}x`;
            shakeRepetitionsInput.value = shakeSettings.repetitions;
            shakeDistanceSlider.value = shakeSettings.distance;
            shakeDistanceValueDisplay.textContent = `${shakeSettings.distance}px`;

            circleSpeedSlider.value = circleSettings.speed;
            circleSpeedValueDisplay.textContent = `${circleSettings.speed}x`;
            circleRepetitionsInput.value = circleSettings.repetitions;
            circleRadiusSlider.value = circleSettings.radius;
            circleRadiusValueDisplay.textContent = `${circleSettings.radius}px`;

            flipSpeedSlider.value = flipSettings.speed;
            flipSpeedValueDisplay.textContent = `${flipSettings.speed}x`;
            flipRepetitionsInput.value = flipSettings.repetitions;

            animationSettingsMenu.style.display = 'block';
        });

        document.getElementById('closeAnimationSettings').addEventListener('click', () => {
            animationSettingsMenu.style.display = 'none';
        });

        document.getElementById('saveAnimationSettings').addEventListener('click', () => {
            shakeSettings = {
                speed: parseFloat(shakeSpeedSlider.value),
                repetitions: parseInt(shakeRepetitionsInput.value),
                distance: parseInt(shakeDistanceSlider.value)
            };
            circleSettings = {
                speed: parseFloat(circleSpeedSlider.value),
                repetitions: parseInt(circleRepetitionsInput.value),
                radius: parseInt(circleRadiusSlider.value)
            };
            flipSettings = {
                speed: parseFloat(flipSpeedSlider.value),
                repetitions: parseInt(flipRepetitionsInput.value)
            };
            animationSettingsMenu.style.display = 'none';
            showShortcutFeedback('Animation settings saved');
        });

        shakeSpeedSlider.addEventListener('input', (e) => shakeSpeedValueDisplay.textContent = `${e.target.value}x`);
        shakeDistanceSlider.addEventListener('input', (e) => shakeDistanceValueDisplay.textContent = `${e.target.value}px`);
        circleSpeedSlider.addEventListener('input', (e) => circleSpeedValueDisplay.textContent = `${e.target.value}x`);
        circleRadiusSlider.addEventListener('input', (e) => circleRadiusValueDisplay.textContent = `${e.target.value}px`);
        flipSpeedSlider.addEventListener('input', (e) => flipSpeedValueDisplay.textContent = `${e.target.value}x`);


        // Text Popup functionality
        const textPopup = document.getElementById('textPopup');
        const popupTextInput = document.getElementById('popupTextInput');
        const colorPicker = document.getElementById('colorPicker');
        const fontPicker = document.getElementById('fontPicker');
        const fontSizeSlider = document.getElementById('fontSizeSlider');
        const fontSizeValue = document.getElementById('fontSizeValue');
        const textPreview = document.getElementById('textPreview');

        document.getElementById('addText').addEventListener('click', () => {
            textPopup.style.display = 'block';
            // Reset to default values when opening
            popupTextInput.value = 'New Text';
            colorPicker.value = '#ffffff';
            fontPicker.value = 'Arial';
            fontSizeSlider.value = '24';
            fontSizeValue.textContent = '24px';
            updateTextPreview();
        });

        document.getElementById('cancelTextButton').addEventListener('click', () => {
            textPopup.style.display = 'none';
        });

        popupTextInput.addEventListener('input', updateTextPreview);
        colorPicker.addEventListener('input', updateTextPreview);
        fontPicker.addEventListener('change', updateTextPreview);
        fontSizeSlider.addEventListener('input', () => {
            fontSizeValue.textContent = `${fontSizeSlider.value}px`;
            updateTextPreview();
        });

        function updateTextPreview() {
            textPreview.textContent = popupTextInput.value || 'Preview Text';
            textPreview.style.color = colorPicker.value;
            textPreview.style.fontFamily = fontPicker.value;
            textPreview.style.fontSize = `${fontSizeSlider.value}px`;
            
            // Adjust background color for contrast (simple logic)
            const hex = colorPicker.value.substring(1);
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
            const brightness = ((r * 299) + (g * 587) + (b * 114)) / 1000;
            textPreview.style.backgroundColor = brightness > 125 ? 'rgba(0,0,0,0.6)' : 'rgba(255,255,255,0.2)';
        }

        let currentTextNode = null; // To keep track of the text node being edited

        document.getElementById('addTextButton').addEventListener('click', () => {
            const textContent = popupTextInput.value || 'New Text';
            const color = colorPicker.value;
            const font = fontPicker.value;
            const fontSize = parseInt(fontSizeSlider.value);
            const uniqueId = 'text_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

            // Add text to assets panel as well
            assetCache.set(uniqueId, { 
                asset: textContent, // Store the text itself
                type: 'text', 
                text: textContent, 
                fontSize: fontSize, 
                fill: color, 
                fontFamily: font 
            });

            const assetsList = document.getElementById('assetsList');
            const assetContainer = document.createElement('div');
            assetContainer.className = 'asset-container';
            assetContainer.draggable = true;
            assetContainer.dataset.assetId = uniqueId;
            assetContainer.dataset.assetType = 'text';

            const textThumbnail = document.createElement('div');
            textThumbnail.className = 'asset-thumbnail';
            textThumbnail.style.backgroundColor = 'rgba(0,0,0,0.3)';
            textThumbnail.style.color = color;
            textThumbnail.style.fontFamily = font;
            textThumbnail.style.fontSize = `${fontSize * 0.5}px` // Smaller font for thumbnail
            textThumbnail.style.padding = '5px';
            textThumbnail.style.display = 'flex';
            textThumbnail.style.alignItems = 'center';
            textThumbnail.style.justifyContent = 'center';
            textThumbnail.style.textAlign = 'center';
            textThumbnail.style.overflow = 'hidden';
            textThumbnail.style.textOverflow = 'ellipsis';
            textThumbnail.innerHTML = textContent.length > 20 ? textContent.substring(0,17) + '...' : textContent;
            assetContainer.appendChild(textThumbnail);

            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'asset-delete-btn';
            deleteBtn.innerHTML = '&times;';
            deleteBtn.onclick = (e) => {
                e.stopPropagation();
                deleteAsset(uniqueId, assetContainer, false);
            };
            assetContainer.appendChild(deleteBtn);
            assetsList.appendChild(assetContainer);

            textPopup.style.display = 'none';
            showShortcutFeedback('Text added to Media Library');
            openAssetsPanel(); // Open panel to show the newly added text asset
        });

        // Make the text popup draggable
        let isDraggingTextPopup = false;
        let textPopupOffsetX, textPopupOffsetY;

        document.getElementById('textPopupTitleBar').addEventListener('mousedown', (e) => {
            isDraggingTextPopup = true;
            textPopupOffsetX = e.clientX - textPopup.getBoundingClientRect().left;
            textPopupOffsetY = e.clientY - textPopup.getBoundingClientRect().top;
            textPopup.style.cursor = 'grabbing';
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDraggingTextPopup) return;
            textPopup.style.left = `${e.clientX - textPopupOffsetX}px`;
            textPopup.style.top = `${e.clientY - textPopupOffsetY}px`;
        });

        document.addEventListener('mouseup', () => {
            isDraggingTextPopup = false;
            textPopup.style.cursor = 'grab';
        });

        // Assets panel toggle
        assetsPanelToggle.addEventListener('click', () => {
            assetsPanel.classList.toggle('expanded');
            if (assetsPanel.classList.contains('expanded')) {
                assetsPanelToggle.innerHTML = '▶';
                assetsPanelToggle.title = 'Collapse Media Library';
            } else {
                assetsPanelToggle.innerHTML = '◀';
                assetsPanelToggle.title = 'Expand Media Library';
            }
            // Resize stage when assets panel expands/collapses
            resizeStage();
        });

        // Event listener for the new "Set Background Image" button
        document.getElementById('setBackgroundImage').addEventListener('click', () => {
            document.getElementById('background-image-input').click();
        });

        // Resize stage function for consistency
        function resizeStage() {
            if (!stage) return;
            const toolbarWidth = document.getElementById('toolbar').offsetWidth;
            const assetsPanelWidth = assetsPanel.classList.contains('expanded') ? assetsPanel.offsetWidth : 0;
            stage.width(window.innerWidth - toolbarWidth - assetsPanelWidth);
            stage.height(window.innerHeight);

            // If there's a background image, re-scale and re-center it
            const currentBg = backgroundLayer.findOne('.background_image');
            if (currentBg) {
                const img = currentBg.image();
                if (img) {
                    const stageWidth = stage.width();
                    const stageHeight = stage.height();

                    const scaleX = stageWidth / img.width;
                    const scaleY = stageHeight / img.height;
                    const scale = Math.max(scaleX, scaleY);

                    const newWidth = img.width * scale;
                    const newHeight = img.height * scale;

                    const x = (stageWidth - newWidth) / 2;
                    const y = (stageHeight - newHeight) / 2;

                    currentBg.setAttrs({
                        x: x,
                        y: y,
                        width: newWidth,
                        height: newHeight
                    });
                    backgroundLayer.draw();
                }
            }
            layer.draw(); // Redraw main layer to ensure everything is visible
        }

        /**
         * Changes the background color of the canvas container.
         * @param {string} color - The hexadecimal color string (e.g., '#RRGGBB').
         */
        function changeBackgroundColor(color) {
            // Fix: Change the container background color instead of document.body
            document.getElementById('container').style.backgroundColor = color;
            showShortcutFeedback(`Background changed to ${color}`);
        }

        // Initialize Konva Stage and Layer
        function initializeApp() {
            try {
                const container = document.getElementById('container');
                stage = new Konva.Stage({
                    container: 'container',
                    width: window.innerWidth - (document.getElementById('toolbar').offsetWidth + (assetsPanel.classList.contains('expanded') ? assetsPanel.offsetWidth : 0)),
                    height: window.innerHeight,
                });

                backgroundLayer = new Konva.Layer(); // Initialize background layer
                stage.add(backgroundLayer); // Add background layer first

                layer = new Konva.Layer(); // Main content layer
                stage.add(layer); // Add main layer second

                transformer = new Konva.Transformer({
                    nodes: [],
                    centeredScaling: false,
                    enabledAnchors: ['top-left', 'top-right', 'bottom-left', 'bottom-right'],
                    borderStroke: '#34c759', // Default green
                    borderStrokeWidth: 2,
                    anchorStroke: '#34c759', // Default green
                    anchorFill: '#34c759', // Default green
                    anchorSize: 12,
                    rotateEnabled: true,
                    rotationSnaps: [0, 90, 180, 270],
                    keepRatio: true, // Keep aspect ratio by default
                });
                layer.add(transformer);

                // Deselect on stage click
                stage.on('click tap', (e) => {
                    // Only clear transformer if clicked on stage or a non-selectable element
                    if (e.target === stage || e.target === layer || e.target === backgroundLayer) {
                        transformer.nodes([]);
                        layer.draw();
                    }
                });

                // Attach event listeners for color swatches
                const colorSwatches = document.querySelectorAll('.color-swatch');
                colorSwatches.forEach(swatch => {
                    swatch.addEventListener('click', () => {
                        const color = swatch.dataset.color;
                        changeBackgroundColor(color);
                    });
                });

                // Attach onchange event listeners to file inputs
                document.getElementById('file-input').addEventListener('change', (e) => handleFiles(e.target.files));
                document.getElementById('folder-input').addEventListener('change', (e) => handleFolderFiles(e.target.files));
                document.getElementById('background-image-input').addEventListener('change', (e) => handleBackgroundImage(e.target.files));

                // Handle resizing
                window.addEventListener('resize', resizeStage);

                // Clear all animations and media on page unload to prevent memory leaks
                window.addEventListener('beforeunload', () => {
                    activeGifAnimations.forEach((animation) => {
                        if (animation && animation.stop) {
                            animation.stop();
                        }
                    });
                    activeGifAnimations.clear();

                    // Stop all other animations
                    activeAnimations.forEach((animation) => {
                        if (animation && animation.stop) {
                            animation.stop();
                        }
                    });
                    activeAnimations.clear();

                    // Clean up media elements
                    mediaElements.forEach((element) => {
                        if (element.pause) element.pause();
                        if (element.remove) element.remove();
                    });
                    mediaElements.clear();
                    
                    // Clear asset cache
                    assetCache.clear();
                });

                console.log('Gaze Tracker Canvas initialized successfully');
            } catch (e) {
                console.error('Error initializing app:', e);
                showError('Failed to initialize application');
            }
        }

        // Initialize the app when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeApp);
        } else {
            initializeApp();
        }
    </script>
</body>
</html>