<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gaze Tracker Canvas</title>
    <script src="https://unpkg.com/konva@9.3.11/konva.min.js"></script>
    <script src="https://unpkg.com/gifler@0.1.0/gifler.min.js"></script> <!-- Added gifler for better GIF handling -->
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            display: flex;
            background-color: #000000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #toolbar {
            width: 60px;
            height: 100vh;
            padding: 8px 4px;
            box-shadow: 2px 0 8px rgba(0,0,0,0.2);
            display: block;
            transition: all 0.3s ease;
            background: linear-gradient(180deg, #3a3836 0%, #2a2826 100%);
            border-right: 1px solid rgba(255,255,255,0.1);
            overflow-y: auto;
            overflow-x: hidden;
        }

        .toolbar-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100%;
            padding-bottom: 100px; /* Ensure scrollable space */
        }

        .toolbar-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px 0;
            width: 100%;
        }

        .toolbar-group-label {
            font-size: 10px;
            color: rgba(255,255,255,0.6);
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
        }

        .toolbar-divider {
            width: 80%;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            margin: 8px 0;
        }

        #container {
            flex: 1;
            height: 100vh;
            background-color: #000000;
            transition: background-color 0.3s ease;
            position: relative;
        }
        
        #container.drag-over {
            outline: 3px dashed rgba(52, 199, 89, 0.5);
            outline-offset: -10px;
            background-color: rgba(52, 199, 89, 0.05);
        }

        .toolbar-button, .color-swatch {
            width: 44px;
            height: 44px;
            margin: 3px;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .toolbar-button {
            background: linear-gradient(145deg, rgba(80, 80, 80, 0.3), rgba(60, 60, 60, 0.2));
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #e0e0e0;
            backdrop-filter: blur(10px);
        }

        .toolbar-button:hover {
            background: linear-gradient(145deg, rgba(120, 120, 120, 0.4), rgba(100, 100, 100, 0.3));
            border-color: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .toolbar-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        .color-swatch {
            border: 2px solid rgba(255, 255, 255, 0.3);
            position: relative;
            overflow: hidden;
        }

        .color-swatch::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: inherit;
            border-radius: inherit;
        }

        .color-swatch:hover {
            transform: scale(1.1);
            border-color: rgba(255, 255, 255, 0.6);
            box-shadow: 0 0 16px rgba(255, 255, 255, 0.4);
        }

        .hidden {
            display: none;
        }

        #gif-container {
            position: absolute;
            left: -9999px;
            top: -9999px;
            visibility: hidden;
            pointer-events: none;
        }

        #textPopup {
            display: none;
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(145deg, #4a4642, #3a3632);
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.6);
            z-index: 1000;
            border-radius: 16px;
            width: 320px;
            max-height: 90vh;
            overflow-y: auto;
            overflow-x: hidden;
            backdrop-filter: blur(20px);
        }

        #textPopupTitleBar {
            background: linear-gradient(135deg, #5a5652, #4a4642);
            color: white;
            padding: 16px 20px;
            cursor: move;
            user-select: none;
            display: flex;
            justify-content: center;
            align-items: center;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        #textPopupTitle {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
            text-align: center;
            letter-spacing: 0.5px;
        }

        #textPopupContent {
            padding: 0;
        }

        .text-form-section {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 12px;
            padding: 24px;
            margin: 20px 24px;
            position: relative;
        }

        .text-form-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, rgba(52, 199, 89, 0.6), rgba(52, 199, 89, 0.2));
            border-radius: 12px 12px 0 0;
        }

        .text-form-section-title {
            margin: 0 0 20px 0;
            font-size: 16px;
            font-weight: 600;
            color: #ffffff;
            display: flex;
            align-items: center;
            gap: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .text-form-section-icon {
            font-size: 20px;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(52, 199, 89, 0.2);
            border-radius: 6px;
        }

        .text-form-row {
            margin-bottom: 16px;
        }

        .text-form-row:last-child {
            margin-bottom: 0;
        }

        .text-form-label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .text-form-description {
            font-size: 10px;
            color: rgba(255,255,255,0.6);
            margin-bottom: 8px;
            line-height: 1.3;
        }

        .text-form-input {
            width: 100%;
            padding: 12px 16px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            color: white;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .text-form-input:focus {
            outline: none;
            border-color: rgba(52, 199, 89, 0.5);
            background: rgba(0, 0, 0, 0.6);
            box-shadow: 0 0 0 2px rgba(52, 199, 89, 0.1);
        }

        .text-form-input[type="color"] {
            height: 50px;
            padding: 4px;
            cursor: pointer;
        }

        .text-form-slider-container {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .text-form-slider {
            flex: 1;
            height: 6px;
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .text-form-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #34c759;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid #ffffff;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        .text-form-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #34c759;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid #ffffff;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        .text-form-value-display {
            background: rgba(52, 199, 89, 0.2);
            color: #ffffff;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            min-width: 50px;
            text-align: center;
            border: 1px solid rgba(52, 199, 89, 0.3);
            flex-shrink: 0;
        }

        .text-preview-container {
            margin: 20px 24px;
        }

        #textPreview {
            background: rgba(0, 0, 0, 0.6);
            border: 2px dashed rgba(255,255,255,0.3);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            min-height: 60px;
            cursor: default; /* Changed from move to default */
            transition: all 0.3s ease;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        #textPreview::before {
            content: ''; /* Removed drag indicator */
            position: absolute;
            top: 8px;
            right: 12px;
            font-size: 14px;
            color: rgba(255,255,255,0.4);
        }

        #textPreview:hover {
            background: rgba(0, 0, 0, 0.8);
            border-color: rgba(52, 199, 89, 0.5);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .button-group {
            display: flex;
            gap: 8px;
        }

        .btn {
            flex: 1;
            padding: 12px 16px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #6b6862, #5a5652);
            color: white;
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, #7b7872, #6a6662);
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: rgba(255,255,255,0.8);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .btn-secondary:hover {
            background: rgba(255,255,255,0.2);
            color: white;
        }

        .assets-panel {
            position: fixed;
            right: -200px;
            top: 0;
            width: 200px;
            height: 100vh;
            background: linear-gradient(180deg, #3a3836 0%, #2a2826 100%);
            box-shadow: -4px 0 16px rgba(0,0,0,0.3);
            transition: right 0.3s ease;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            border-left: 1px solid rgba(255,255,255,0.1);
        }

        .assets-panel.expanded {
            right: 0;
        }

        .assets-panel-toggle {
            position: absolute;
            left: -40px;
            top: 20px;
            width: 40px;
            height: 50px;
            background: linear-gradient(135deg, #3a3836, #2a2826);
            border: 1px solid rgba(255,255,255,0.1);
            border-right: none;
            border-radius: 8px 0 0 8px;
            cursor: pointer;
            font-size: 16px;
            color: #e0e0e0;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .assets-panel-toggle:hover {
            background: linear-gradient(135deg, #4a4642, #3a3632);
        }

        .assets-panel-header {
            padding: 20px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .assets-panel-title {
            margin: 0;
            font-size: 16px;
            font-weight: 600;
            color: #e0e0e0;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .assets-panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }
        
        .assets-panel-section-title {
            font-size: 12px;
            color: rgba(255,255,255,0.6);
            margin: 16px 0 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 4px;
        }

        .asset-container {
            position: relative;
            width: 100%;
            height: 120px;
            margin-bottom: 12px;
            border-radius: 8px;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s ease;
        }

        .asset-container:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            border-color: rgba(255,255,255,0.3);
        }

        .asset-thumbnail {
            width: 100%;
            height: 100%;
            object-fit: cover;
            cursor: grab;
            transition: transform 0.3s ease;
        }
        
      .asset-thumbnail:active {
            cursor: grabbing;
        }

        .asset-thumbnail:hover {
            transform: scale(1.05);
        }

        .asset-delete-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            background: rgba(255, 59, 48, 0.9);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: all 0.3s ease;
        }

        .asset-container:hover .asset-delete-btn {
            opacity: 1;
        }

        .asset-delete-btn:hover {
            background: #ff3b30;
            transform: scale(1.1);
        }

        .gif-indicator {
            position: absolute;
            top: 8px;
            left: 8px;
            background: rgba(52, 199, 89, 0.9);
            color: white;
            padding: 2px 6px;
            font-size: 10px;
            border-radius: 4px;
            font-weight: bold;
        }

        #animationSettingsMenu {
            display: none;
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(145deg, #4a4642, #3a3632);
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.6);
            z-index: 1000;
            width: 400px;
            max-height: 90vh;
            overflow-y: auto;
            overflow-x: hidden;
            backdrop-filter: blur(20px);
        }

        .settings-header {
            background: linear-gradient(135deg, #5a5652, #4a4642);
            padding: 20px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            border-radius: 16px 16px 0 0;
        }

        .settings-title {
            margin: 0;
            font-size: 20px;
            font-weight: 600;
            color: white;
            text-align: center;
            letter-spacing: 0.5px;
        }

        .settings-content {
            padding: 24px;
        }

        .settings-section {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 24px;
            position: relative;
        }

        .settings-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, rgba(52, 199, 89, 0.6), rgba(52, 199, 89, 0.2));
            border-radius: 12px 12px 0 0;
        }

        .settings-section-title {
            margin: 0 0 20px 0;
            font-size: 18px;
            font-weight: 600;
            color: #ffffff;
            display: flex;
            align-items: center;
            gap: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .settings-section-icon {
            font-size: 24px;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(52, 199, 89, 0.2);
            border-radius: 8px;
        }

        .settings-row {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 16px;
            align-items: center;
            margin-bottom: 20px;
            padding: 12px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .settings-row:last-child {
            margin-bottom: 0;
        }

        .settings-row-label {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .settings-row-title {
            font-size: 14px;
            font-weight: 600;
            color: #ffffff;
            margin: 0;
        }

        .settings-row-description {
            font-size: 11px;
            color: rgba(255,255,255,0.6);
            margin: 0;
        }

        .settings-row-control {
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 140px;
            flex-shrink: 0;
        }

        .settings-value-display {
            background: rgba(52, 199, 89, 0.2);
            color: #ffffff;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            min-width: 45px;
            text-align: center;
            border: 1px solid rgba(52, 199, 89, 0.3);
            flex-shrink: 0;
        }

        .settings-input-range {
            flex: 1;
            min-width: 80px;
            height: 6px;
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .settings-input-range::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #34c759;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid #ffffff;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        .settings-input-number {
            width: 60px;
            padding: 6px 8px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            color: white;
            font-size: 12px;
            text-align: center;
        }

        .settings-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin-top: 32px;
            padding-top: 24px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        .loading-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 24px 32px;
            border-radius: 12px;
            z-index: 2000;
            display: none;
            font-size: 14px;
            font-weight: 500;
        }

        .folder-loading-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 32px 48px;
            border-radius: 16px;
            z-index: 2000;
            display: none;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }

        .folder-loading-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 16px;
        }

        .folder-loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255,255,255,0.2);
            border-top-color: #34c759;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .folder-loading-text {
            font-size: 16px;
            font-weight: 600;
            margin: 0;
        }

        .folder-loading-details {
            font-size: 12px;
            color: rgba(255,255,255,0.6);
            margin: 0;
        }

        .folder-loading-progress {
            width: 200px;
            height: 4px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 8px;
        }

        .folder-loading-progress-bar {
            height: 100%;
            background: #34c759;
            transition: width 0.3s ease;
            width: 0%;
        }

        .error-message {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #ff3b30;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            z-index: 2000;
            display: none;
            max-width: 80%;
            text-align: center;
            font-weight: 500;
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.3);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255,255,255,0.5);
        }

        .toolbar-help {
            display: none;
        }
        @media (max-width: 768px) {
            #toolbar {
                width: 50px;
            }
            
            .toolbar-button, .color-swatch {
                width: 36px;
                height: 36px;
                font-size: 16px;
            }
            
            #textPopup {
                width: 90%;
                max-width: 320px;
            }
            
            .assets-panel {
                width: 180px;
                right: -180px;
            }
        }
    </style>
</head>
<body>
    <div id="toolbar" role="toolbar" aria-label="Image editing tools">
        <div class="toolbar-content">
            <div class="toolbar-group">
                <div class="toolbar-group-label">Files</div>
                <button class="toolbar-button" id="file-input-button" aria-label="Upload images and videos" title="Upload Media">üìÅ</button>
                <button class="toolbar-button" id="folder-input-button" aria-label="Upload folder" title="Upload Folder">üìÇ</button>
                <button class="toolbar-button" id="setBackgroundImage" aria-label="Set Background Image" title="Set Background Image">‚ñß</button>
                <button class="toolbar-button" id="setForegroundImage" aria-label="Set Foreground Image" title="Upload Foreground Image">‚ñ£</button>
                <button class="toolbar-button" id="fullscreenToggle" aria-label="Toggle fullscreen" title="Toggle Fullscreen - Press F11">‚õ∂</button>
            </div>
            
            <div class="toolbar-divider"></div>
            
            <div class="toolbar-group">
                <div class="toolbar-group-label">Edit</div>
                <button class="toolbar-button" id="addText" aria-label="Add text" title="Add Text">T</button>
                <button class="toolbar-button" id="increaseSize" aria-label="Increase size" title="Increase Size">+</button>
                <button class="toolbar-button" id="decreaseSize" aria-label="Decrease size" title="Decrease Size">-</button>
                <button class="toolbar-button" id="deleteItem" aria-label="Delete item" title="Delete Item">√ó</button>
            </div>
            
            <div class="toolbar-divider"></div>
            
            <div class="toolbar-group">
                <div class="toolbar-group-label">Layer</div>
                <button class="toolbar-button" id="moveUp" aria-label="Move layer up" title="Move Layer Up - Press Ctrl+‚Üë">‚Üë</button>
                <button class="toolbar-button" id="moveDown" aria-label="Move layer down" title="Move Layer Down - Press Ctrl+‚Üì">‚Üì</button>
            </div>
            
            <div class="toolbar-divider"></div>
            
            <div class="toolbar-group">
                <div class="toolbar-group-label">Animate</div>
                <button class="toolbar-button" id="shakeButton" aria-label="Shake item" title="Shake Animation - Press Ctrl+1">‚áÑ</button>
                <button class="toolbar-button" id="circleButton" aria-label="Circular motion" title="Circle Animation - Press Ctrl+2">‚ü≥</button>
                <button class="toolbar-button" id="flipButton" aria-label="Flip direction" title="Flip Direction - Press Ctrl+4">‚Æé</button>
                <button class="toolbar-button" id="animationSettings" aria-label="Animation Settings" title="Animation Settings - Press Ctrl+3">‚öô</button>
            </div>
            
            <div class="toolbar-divider"></div>
            
            <div class="toolbar-group">
                <div class="toolbar-group-label">Theme</div>
                <button class="color-swatch" style="background-color: #faf7e2;" title="Light Buff" data-color="#faf7e2" aria-label="Light Background"></button>
                <button class="color-swatch" style="background-color: #b8b6a8;" title="Buff" data-color="#b8b6a8" aria-label="Medium Background"></button>
                <button class="color-swatch" style="background-color: #37342e;" title="Dark Buff" data-color="#37342e" aria-label="Dark Background"></button>
                <button class="color-swatch" style="background-color: #000000;" title="Black" data-color="#000000" aria-label="Black Background"></button>
            </div>
        </div>
    </div>
    </div>
    
    <main id="container" role="main"></main>

    <div id="gif-container"></div>
    <div id="loadingIndicator" class="loading-indicator">Loading...</div>
    <div id="folderLoadingIndicator" class="folder-loading-indicator">
        <div class="folder-loading-content">
            <div class="folder-loading-spinner"></div>
            <p class="folder-loading-text">Loading folder contents...</p>
            <p class="folder-loading-details">
                <span id="folderLoadingCount">0</span> / <span id="folderLoadingTotal">0</span> files
            </p>
            <div class="folder-loading-progress">
                <div class="folder-loading-progress-bar" id="folderLoadingProgress"></div>
            </div>
        </div>
    </div>
    <div id="errorMessage" class="error-message"></div>

    <input type="file" id="file-input" class="hidden" accept="image/jpeg, image/png, image/gif, video/mp4, video/webm, video/ogg" multiple>
    <input type="file" id="folder-input" class="hidden" webkitdirectory directory multiple>
    <input type="file" id="background-image-input" class="hidden" accept="image/jpeg, image/png">
    <input type="file" id="foreground-image-input" class="hidden" accept="image/jpeg, image/png">

    <div id="textPopup" role="dialog" aria-labelledby="textPopupTitle">
        <div id="textPopupTitleBar">
            <h3 id="textPopupTitle">Text Editor</h3>
        </div>
        <div id="textPopupContent">
            <div class="text-preview-container">
                <div class="text-preview-title">Live Preview</div>
                <div id="textPreview">Preview Text</div> <!-- Removed draggable -->
                <div class="text-form-description" style="margin-top: 8px; text-align: center;">Your text will appear directly on the canvas.</div> <!-- Updated description -->
            </div>
            
            <div class="text-form-section">
                <h4 class="text-form-section-title">
                    <div class="text-form-section-icon">üìù</div>
                    <div>Text Content</div>
                </h4>
                
                <div class="text-form-row">
                    <label class="text-form-label" for="popupTextInput">Text Content</label>
                    <div class="text-form-description">Enter the text you want to display on the canvas</div>
                    <input type="text" id="popupTextInput" class="text-form-input" placeholder="Enter your text here..." />
                </div>
            </div>
            
            <div class="text-form-section">
                <h4 class="text-form-section-title">
                    <div class="text-form-section-icon">üé®</div>
                    <div>Appearance Settings</div>
                </h4>
                
                <div class="text-form-row">
                    <label class="text-form-label" for="colorPicker">Text Color</label>
                    <div class="text-form-description">Choose the color for your text (auto-adjusts for contrast)</div>
                    <input type="color" id="colorPicker" class="text-form-input" value="#ffffff" />
                </div>
                
                <div class="text-form-row">
                    <label class="text-form-label" for="fontPicker">Font Family</label>
                    <div class="text-form-description">Select a font style for better readability</div>
                    <select id="fontPicker" class="text-form-input">
                        <option value="Arial">Arial (Recommended)</option>
                        <option value="Georgia">Georgia</option>
                        <option value="Times New Roman">Times New Roman</option>
                        <option value="Verdana">Verdana</option>
                        <option value="Comic Sans MS">Comic Sans MS</option>
                        <option value="Impact">Impact (Bold)</option>
                        <option value="Courier New">Courier New</option>
                    </select>
                </div>
                
                <div class="text-form-row">
                    <label class="text-form-label" for="fontSizeSlider">Font Size</label>
                    <div class="text-form-description">Adjust text size for optimal visibility</div>
                    <div class="text-form-slider-container">
                        <input type="range" id="fontSizeSlider" class="text-form-slider" min="12" max="72" value="24" />
                        <div class="text-form-value-display" id="fontSizeValue">24px</div>
                    </div>
                </div>
            </div>
            
            <div class="button-group" style="margin: 24px;">
                <button class="btn btn-primary" id="addTextButton">Add to Canvas</button>
                <button class="btn btn-secondary" id="cancelTextButton">Cancel</button>
            </div>
        </div>
    </div>

    <div id="assetsPanel" class="assets-panel">
        <button id="assetsPanelToggle" class="assets-panel-toggle" aria-label="Toggle assets panel">‚óÄ</button>
        <div class="assets-panel-header">
            <h3 class="assets-panel-title">Media Library</h3>
        </div>
        <div class="assets-panel-content">
            <h4 class="assets-panel-section-title">Other Media</h4>
            <div id="assetsList"></div>
            <h4 class="assets-panel-section-title">Background Images</h4>
            <div id="backgroundAssetsList"></div>
            <h4 class="assets-panel-section-title">Foreground Images</h4>
            <div id="foregroundAssetsList"></div>
            <!-- Removed Text section -->
        </div>
    </div>

    <div id="animationSettingsMenu">
        <div class="settings-header">
            <h3 class="settings-title">Animation Settings</h3>
        </div>
        <div class="settings-content">
            <div class="settings-section">
                <h4 class="settings-section-title">
                    <div class="settings-section-icon">‚áÑ</div>
                    <div>
                        <div>Shake Animation</div>
                        <div style="font-size: 11px; color: rgba(255,255,255,0.6); font-weight: 400;">Horizontal back-and-forth movement</div>
                    </div>
                </h4>
                
                <div class="settings-row">
                    <div class="settings-row-label">
                        <div class="settings-row-title">Animation Speed</div>
                        <div class="settings-row-description">How fast the shaking motion occurs</div>
                    </div>
                    <div class="settings-row-control">
                        <input type="range" id="shakeSpeed" class="settings-input-range" min="0.1" max="1.3" step="0.1" value="0.7">
                        <div class="settings-value-display" id="shakeSpeedValue">0.7x</div>
                    </div>
                </div>
                
                <div class="settings-row">
                    <div class="settings-row-label">
                        <div class="settings-row-title">Repetitions</div>
                        <div class="settings-row-description">Number of complete shake cycles</div>
                    </div>
                    <div class="settings-row-control">
                        <input type="number" id="shakeRepetitions" class="settings-input-number" min="1" max="10" value="3">
                    </div>
                </div>
                
                <div class="settings-row">
                    <div class="settings-row-label">
                        <div class="settings-row-title">Movement Distance</div>
                        <div class="settings-row-description">How far the object moves left and right</div>
                    </div>
                    <div class="settings-row-control">
                        <input type="range" id="shakeDistance" class="settings-input-range" min="10" max="200" step="10" value="100">
                        <div class="settings-value-display" id="shakeDistanceValue">100px</div>
                    </div>
                </div>
            </div>
            
            <div class="settings-section">
                <h4 class="settings-section-title">
                    <div class="settings-section-icon">‚ü≥</div>
                    <div>
                        <div>Circle Animation</div>
                        <div style="font-size: 11px; color: rgba(255,255,255,0.6); font-weight: 400;">Circular orbital movement pattern</div>
                    </div>
                </h4>
                
                <div class="settings-row">
                    <div class="settings-row-label">
                        <div class="settings-row-title">Animation Speed</div>
                        <div class="settings-row-description">How fast the circular motion occurs</div>
                    </div>
                    <div class="settings-row-control">
                        <input type="range" id="circleSpeed" class="settings-input-range" min="0.1" max="2" step="0.1" value="0.5">
                        <div class="settings-value-display" id="circleSpeedValue">0.5x</div>
                    </div>
                </div>
                
                <div class="settings-row">
                    <div class="settings-row-label">
                        <div class="settings-row-title">Repetitions</div>
                        <div class="settings-row-description">Number of complete circular rotations</div>
                    </div>
                    <div class="settings-row-control">
                        <input type="number" id="circleRepetitions" class="settings-input-number" min="1" max="10" value="3">
                    </div>
                </div>
                
                <div class="settings-row">
                    <div class="settings-row-label">
                        <div class="settings-row-title">Circle Radius</div>
                        <div class="settings-row-description">Size of the circular movement path</div>
                    </div>
                    <div class="settings-row-control">
                        <input type="range" id="circleRadius" class="settings-input-range" min="10" max="200" step="10" value="50">
                        <div class="settings-value-display" id="circleRadiusValue">50px</div>
                    </div>
                </div>
            </div>
            
            <div class="settings-section">
                <h4 class="settings-section-title">
                    <div class="settings-section-icon">‚Æé</div>
                    <div>
                        <div>Flip Animation</div>
                        <div style="font-size: 11px; color: rgba(255,255,255,0.6); font-weight: 400;">Horizontal flip to change direction</div>
                    </div>
                </h4>
                
                <div class="settings-row">
                    <div class="settings-row-label">
                        <div class="settings-row-title">Animation Speed</div>
                        <div class="settings-row-description">How fast the flipping motion occurs</div>
                    </div>
                    <div class="settings-row-control">
                        <input type="range" id="flipSpeed" class="settings-input-range" min="0.3" max="2" step="0.1" value="1">
                        <div class="settings-value-display" id="flipSpeedValue">1x</div>
                    </div>
                </div>
                
                <div class="settings-row">
                    <div class="settings-row-label">
                        <div class="settings-row-title">Repetitions</div>
                        <div class="settings-row-description">Number of complete flip cycles</div>
                    </div>
                    <div class="settings-row-control">
                        <input type="number" id="flipRepetitions" class="settings-input-number" min="1" max="5" value="1">
                    </div>
                </div>
            </div>
            
            <div class="settings-buttons">
                <button class="btn btn-primary" id="saveAnimationSettings">Apply Settings</button>
                <button class="btn btn-secondary" id="closeAnimationSettings">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        class GazeTrackerApp {
            constructor() {
                // Konva Stage and Layers
                this.stage = null;
                this.layer = null;
                this.transformer = null;
                this.backgroundLayer = null;
                this.foregroundLayer = null;

                // Animation Settings
                this.shakeSettings = { speed: 0.7, repetitions: 3, distance: 100 };
                this.circleSettings = { speed: 0.5, repetitions: 3, radius: 50 }; 
                this.flipSettings = { speed: 1, repetitions: 1 };

                // Maps for managing Konva nodes and assets
                this.activeGifAnimations = new Map(); // Track active GIF animations
                this.activeAnimations = new Map(); // Track all Konva.Animation instances
                this.mediaElements = new Map(); // Track all Konva nodes added to main layer
                this.assetCache = new Map(); // Cache loaded assets (HTMLImageElement, HTMLVideoElement, text data)

                // References to current fixed layers and last selected node
                this.currentBackgroundNode = null;
                this.currentForegroundNode = null;
                this.lastSelectedNode = null;

                // DOM Elements (cached for performance)
                this.elements = {
                    container: document.getElementById('container'),
                    toolbar: document.getElementById('toolbar'),
                    loadingIndicator: document.getElementById('loadingIndicator'),
                    folderLoadingIndicator: document.getElementById('folderLoadingIndicator'),
                    folderLoadingCount: document.getElementById('folderLoadingCount'),
                    folderLoadingTotal: document.getElementById('folderLoadingTotal'),
                    folderLoadingProgress: document.getElementById('folderLoadingProgress'),
                    errorMessage: document.getElementById('errorMessage'),
                    fileInput: document.getElementById('file-input'),
                    folderInput: document.getElementById('folder-input'),
                    backgroundImageInput: document.getElementById('background-image-input'),
                    foregroundImageInput: document.getElementById('foreground-image-input'),
                    assetsPanel: document.getElementById('assetsPanel'),
                    assetsPanelToggle: document.getElementById('assetsPanelToggle'),
                    assetsList: document.getElementById('assetsList'),
                    backgroundAssetsList: document.getElementById('backgroundAssetsList'),
                    foregroundAssetsList: document.getElementById('foregroundAssetsList'),
                    textPopup: document.getElementById('textPopup'),
                    textPopupTitleBar: document.getElementById('textPopupTitleBar'),
                    popupTextInput: document.getElementById('popupTextInput'),
                    colorPicker: document.getElementById('colorPicker'),
                    fontPicker: document.getElementById('fontPicker'),
                    fontSizeSlider: document.getElementById('fontSizeSlider'),
                    fontSizeValue: document.getElementById('fontSizeValue'),
                    textPreview: document.getElementById('textPreview'),
                    animationSettingsMenu: document.getElementById('animationSettingsMenu'),
                    shakeSpeedSlider: document.getElementById('shakeSpeed'),
                    shakeSpeedValueDisplay: document.getElementById('shakeSpeedValue'),
                    shakeRepetitionsInput: document.getElementById('shakeRepetitions'),
                    shakeDistanceSlider: document.getElementById('shakeDistance'),
                    shakeDistanceValueDisplay: document.getElementById('shakeDistanceValue'),
                    circleSpeedSlider: document.getElementById('circleSpeed'),
                    circleSpeedValueDisplay: document.getElementById('circleSpeedValue'),
                    circleRepetitionsInput: document.getElementById('circleRepetitions'),
                    circleRadiusSlider: document.getElementById('circleRadius'),
                    circleRadiusValueDisplay: document.getElementById('circleRadiusValue'),
                    flipSpeedSlider: document.getElementById('flipSpeed'),
                    flipSpeedValueDisplay: document.getElementById('flipSpeedValue'),
                    flipRepetitionsInput: document.getElementById('flipRepetitions'),
                };
            }

            /**
             * Initializes the Konva stage, layers, and attaches all event listeners.
             */
            init() {
                try {
                    this.stage = new Konva.Stage({
                        container: this.elements.container.id,
                        width: window.innerWidth - this.elements.toolbar.offsetWidth,
                        height: window.innerHeight,
                    });

                    this.backgroundLayer = new Konva.Layer();
                    this.stage.add(this.backgroundLayer);

                    this.layer = new Konva.Layer(); // Main content layer
                    this.stage.add(this.layer);

                    this.foregroundLayer = new Konva.Layer();
                    this.stage.add(this.foregroundLayer);

                    this.transformer = new Konva.Transformer({
                        nodes: [],
                        centeredScaling: false,
                        enabledAnchors: ['top-left', 'top-right', 'bottom-left', 'bottom-right'],
                        borderStroke: '#34c759',
                        borderStrokeWidth: 2,
                        anchorStroke: '#34c759',
                        anchorFill: '#34c759',
                        anchorSize: 12,
                        rotateEnabled: true,
                        rotationSnaps: [0, 90, 180, 270],
                        keepRatio: true,
                    });
                    this.layer.add(this.transformer);

                    this.addEventListeners();
                    console.log('Gaze Tracker Canvas initialized successfully');
                } catch (e) {
                    console.error('Error initializing app:', e);
                    this.showError('Failed to initialize application');
                }
            }

            /**
             * Attaches all DOM and Konva event listeners.
             */
            addEventListeners() {
                // Konva Stage Events
                this.stage.on('click tap', this.handleStageClick.bind(this));

                // File Input Buttons
                document.getElementById('file-input-button').addEventListener('click', () => this.elements.fileInput.click());
                document.getElementById('folder-input-button').addEventListener('click', () => this.elements.folderInput.click());
                document.getElementById('setBackgroundImage').addEventListener('click', () => this.elements.backgroundImageInput.click());
                
                // Set Foreground Image button now ONLY triggers the file input.
                document.getElementById('setForegroundImage').addEventListener('click', () => this.elements.foregroundImageInput.click());

                // File Input Change Handlers
                this.elements.fileInput.addEventListener('change', (e) => this.handleFiles(e.target.files));
                this.elements.folderInput.addEventListener('change', (e) => this.handleFolderFiles(e.target.files));
                this.elements.backgroundImageInput.addEventListener('change', (e) => this.handleBackgroundImage(e.target.files));
                
                // This listener correctly processes the selected file.
                this.elements.foregroundImageInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        this.processAndSetForegroundImage(e.target.files[0]);
                    }
                });

                // Fullscreen Toggle
                this.elements.toolbar.querySelector('#fullscreenToggle').addEventListener('click', this.toggleFullscreen.bind(this));
                document.addEventListener('fullscreenchange', this.updateFullscreenButton.bind(this));

                // Toolbar Action Buttons
                document.getElementById('increaseSize').addEventListener('click', this.increaseSize.bind(this));
                document.getElementById('decreaseSize').addEventListener('click', this.decreaseSize.bind(this));
                document.getElementById('deleteItem').addEventListener('click', this.deleteSelectedItem.bind(this));
                document.getElementById('moveUp').addEventListener('click', this.moveLayerUp.bind(this));
                document.getElementById('moveDown').addEventListener('click', this.moveLayerDown.bind(this));
                document.getElementById('shakeButton').addEventListener('click', this.applyShakeAnimation.bind(this));
                document.getElementById('circleButton').addEventListener('click', this.applyCircleAnimation.bind(this));
                document.getElementById('flipButton').addEventListener('click', this.applyFlipAnimation.bind(this));
                document.getElementById('animationSettings').addEventListener('click', this.showAnimationSettings.bind(this));

                // Theme Color Swatches
                document.querySelectorAll('.color-swatch').forEach(swatch => {
                    swatch.addEventListener('click', (e) => this.changeBackgroundColor(e.target.dataset.color));
                });

                // Hotkey Listener
                document.addEventListener('keydown', this.handleHotkeys.bind(this));

                // Text Popup Functionality
                document.getElementById('addText').addEventListener('click', this.showTextPopup.bind(this));
                document.getElementById('cancelTextButton').addEventListener('click', () => this.elements.textPopup.style.display = 'none');
                this.elements.popupTextInput.addEventListener('input', this.updateTextPreview.bind(this));
                this.elements.colorPicker.addEventListener('input', this.updateTextPreview.bind(this));
                this.elements.fontPicker.addEventListener('change', this.updateTextPreview.bind(this));
                this.elements.fontSizeSlider.addEventListener('input', () => {
                    this.elements.fontSizeValue.textContent = `${this.elements.fontSizeSlider.value}px`;
                    this.updateTextPreview();
                });
                document.getElementById('addTextButton').addEventListener('click', this.addTextToCanvas.bind(this));
                this.makeTextPopupDraggable();

                // Assets Panel Toggle
                this.elements.assetsPanelToggle.addEventListener('click', this.toggleAssetsPanel.bind(this));

                // Drag and Drop for Assets Panel
                this.elements.assetsList.addEventListener('dragstart', this.handleAssetDragStart.bind(this));
                this.elements.backgroundAssetsList.addEventListener('dragstart', this.handleAssetDragStart.bind(this));
                this.elements.foregroundAssetsList.addEventListener('dragstart', this.handleAssetDragStart.bind(this));
                this.elements.container.addEventListener('dragover', this.handleDragOver.bind(this));
                this.elements.container.addEventListener('dragleave', this.handleDragLeave.bind(this));
                this.elements.container.addEventListener('drop', this.handleDrop.bind(this));

                // Animation Settings Menu Controls
                document.getElementById('closeAnimationSettings').addEventListener('click', () => this.elements.animationSettingsMenu.style.display = 'none');
                document.getElementById('saveAnimationSettings').addEventListener('click', this.saveAnimationSettings.bind(this));
                this.elements.shakeSpeedSlider.addEventListener('input', (e) => this.elements.shakeSpeedValueDisplay.textContent = `${e.target.value}x`);
                this.elements.shakeDistanceSlider.addEventListener('input', (e) => this.elements.shakeDistanceValueDisplay.textContent = `${e.target.value}px`);
                this.elements.circleSpeedSlider.addEventListener('input', (e) => this.elements.circleSpeedValueDisplay.textContent = `${e.target.value}x`);
                this.elements.circleRadiusSlider.addEventListener('input', (e) => this.elements.circleRadiusValueDisplay.textContent = `${e.target.value}px`);
                this.elements.flipSpeedSlider.addEventListener('input', (e) => this.elements.flipSpeedValueDisplay.textContent = `${e.target.value}x`);
                
                // Window Resize Listener
                window.addEventListener('resize', this.resizeStage.bind(this));

                // Cleanup on unload
                window.addEventListener('beforeunload', this.cleanup.bind(this));
            }

            /**
             * Handles clicks on the Konva stage to deselect items.
             * @param {Konva.KonvaEventObject<MouseEvent>} e - The Konva click event.
             */
            handleStageClick(e) {
                // If clicked on the stage background itself or a non-interactive layer
                if (e.target === this.stage || e.target === this.layer || e.target === this.backgroundLayer || e.target === this.foregroundLayer) {
                    this.transformer.nodes([]);
                    this.layer.draw();
                }
            }

            /** Utility Functions **/

            showLoading() {
                this.elements.loadingIndicator.style.display = 'block';
            }

            hideLoading() {
                this.elements.loadingIndicator.style.display = 'none';
            }

            showFolderLoading(current, total) {
                this.elements.folderLoadingIndicator.style.display = 'block';
                this.elements.folderLoadingCount.textContent = current;
                this.elements.folderLoadingTotal.textContent = total;
                const percentage = total > 0 ? (current / total) * 100 : 0;
                this.elements.folderLoadingProgress.style.width = percentage + '%';
            }

            hideFolderLoading() {
                this.elements.folderLoadingIndicator.style.display = 'none';
            }

            showShortcutFeedback(message) {
                let feedback = document.getElementById('shortcutFeedback');
                if (!feedback) {
                    feedback = document.createElement('div');
                    feedback.id = 'shortcutFeedback';
                    feedback.style.cssText = `
                        position: fixed;
                        top: 20px;
                        left: 50%;
                        transform: translateX(-50%);
                        background: rgba(52, 199, 89, 0.9);
                        color: white;
                        padding: 8px 16px;
                        border-radius: 6px;
                        font-size: 12px;
                        font-weight: 600;
                        z-index: 2001;
                        opacity: 0;
                        transition: opacity 0.3s ease;
                        pointer-events: none;
                    `;
                    document.body.appendChild(feedback);
                }
                feedback.textContent = message;
                feedback.style.opacity = '1';
                if (feedback.hideTimeout) {
                    clearTimeout(feedback.hideTimeout);
                }
                feedback.hideTimeout = setTimeout(() => {
                    feedback.style.opacity = '0';
                }, 1500);
            }

            showError(message) {
                this.elements.errorMessage.textContent = message;
                this.elements.errorMessage.style.display = 'block';
                setTimeout(() => {
                    this.elements.errorMessage.style.display = 'none';
                }, 3000);
            }

            /**
             * Updates the Konva Transformer based on the selected node.
             * @param {Konva.Node|null} node - The Konva node to select, or null to deselect.
             */
            updateActiveElement(node) {
                if (!this.layer || !this.transformer) return;

                try {
                    // Only select fixed layers (background/foreground) if they are explicitly passed and are `listening: true`.
                    // However, we've set foreground to `listening: false` to allow click-through.
                    // So, the transformer should only appear on fixed layers if we programmatically select them,
                    // or if it's the background image which is still `listening: true`.
                    if (node && (node.name() === 'background_image' || node.name() === 'foreground_image')) {
                        this.transformer.nodes([node]); // Select the node
                        this.transformer.moveToTop(); // Ensure transformer is visible
                        this.transformer.borderStroke('#FFFF00'); // Yellow border for fixed layers
                        this.transformer.anchorStroke('#FFFF00');
                        this.transformer.anchorFill('#FFFF00');
                        this.lastSelectedNode = node; // Keep track for delete, etc.
                    } else if (node) {
                        // Regular draggable elements
                        this.transformer.nodes([node]);
                        this.transformer.moveToTop();
                        this.transformer.borderStroke('#34c759'); // Default green for draggable elements
                        this.transformer.anchorStroke('#34c759');
                        this.transformer.anchorFill('#34c759');
                        this.lastSelectedNode = node;
                    } else {
                        // Deselect all
                        this.transformer.nodes([]);
                        this.transformer.borderStroke('#34c759'); // Reset to default green
                        this.transformer.anchorStroke('#34c759');
                        this.transformer.anchorFill('#34c759');
                    }
                    this.layer.draw();
                } catch (e) {
                    console.error('Error updating active element:', e);
                }
            }

            /**
             * Gets the currently selected node for applying actions like animations.
             * Prefers the transformer's node, falls back to the last selected.
             * @returns {Konva.Node|null} The target Konva node.
             */
            getTargetNode() {
                const currentlySelected = this.transformer.nodes()[0];
                return currentlySelected || this.lastSelectedNode;
            }

            /** File Handling Utilities **/

            validateFile(file) {
                const maxSize = 50 * 1024 * 1024; // 50MB limit
                const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'video/mp4', 'video/webm', 'video/ogg'];
                if (file.size > maxSize) {
                    this.showError(`File "${file.name}" is too large. Maximum size is 50MB.`);
                    return false;
                }
                if (!allowedTypes.includes(file.type)) {
                    return false; // Silently skip unsupported types in folder uploads
                }
                return true;
            }

            loadImageElement(src) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = (e) => reject(new Error(`Failed to load image element from ${src}: ${e.message}`));
                    img.src = src;
                });
            }

            createVideoElement(src) {
                return new Promise((resolve, reject) => {
                    const videoElement = document.createElement('video');
                    videoElement.src = src;
                    videoElement.loop = true;
                    videoElement.muted = true;
                    videoElement.setAttribute('webkit-playsinline', 'webkit-playsinline');
                    videoElement.setAttribute('playsinline', 'playsinline');
                    videoElement.style.display = 'none';
                    document.body.appendChild(videoElement);

                    videoElement.onloadedmetadata = () => {
                        videoElement.play().catch(e => console.warn("Video autoplay prevented:", e));
                        resolve(videoElement);
                    };
                    videoElement.onerror = (e) => {
                        console.error("Video element loading error:", e);
                        reject(new Error(`Failed to load video element from ${src}`));
                    };
                });
            }
            // Removed createImageFromCharacter function as it's no longer needed.

            /** File Input Handlers **/

            async handleFiles(files) {
                if (!files || files.length === 0) return;
                for (const file of Array.from(files)) {
                    if (!this.validateFile(file)) continue;
                    this.showLoading();
                    try {
                        const dataUrl = await new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onload = (e) => resolve(e.target.result);
                            reader.onerror = reject;
                            reader.readAsDataURL(file);
                        });
                        const uniqueId = `${file.type.split('/')[0]}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

                        if (file.type.startsWith('image/')) {
                            const img = await this.loadImageElement(dataUrl);
                            this.addToAssetsPanel(img, uniqueId, file.type.includes('gif') ? 'gif' : 'image');
                        } else if (file.type.startsWith('video/')) {
                            const videoElement = await this.createVideoElement(dataUrl);
                            this.addToAssetsPanel(videoElement, uniqueId, 'video'); 
                        }
                        this.hideLoading();
                    } catch (error) {
                        this.hideLoading();
                        this.showError(`Failed to load "${file.name}": ${error.message}`);
                    }
                }
            }

            async handleFolderFiles(files) {
                if (!files || files.length === 0) {
                    this.showError('No files selected in folder.');
                    return;
                }

                const validFiles = Array.from(files).filter(file => this.validateFile(file));
                if (validFiles.length === 0) {
                    this.showError('No valid image or video files found in the selected folder.');
                    this.hideFolderLoading();
                    return;
                }

                let loadedCount = 0;
                this.showFolderLoading(loadedCount, validFiles.length);

                for (const file of validFiles) {
                    try {
                        const dataUrl = await new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onload = (e) => resolve(e.target.result);
                            reader.onerror = reject;
                            reader.readAsDataURL(file);
                        });
                        const uniqueId = `${file.type.split('/')[0]}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

                        if (file.type.startsWith('image/')) {
                            const img = await this.loadImageElement(dataUrl);
                            this.addToAssetsPanel(img, uniqueId, file.type.includes('gif') ? 'gif' : 'image');
                        } else if (file.type.startsWith('video/')) {
                            const videoElement = await this.createVideoElement(dataUrl);
                            this.addToAssetsPanel(videoElement, uniqueId, 'video');
                        }
                    } catch (error) {
                        console.error('Error processing file from folder:', file.name, error);
                        this.showError(`Failed to load "${file.name}" from folder.`);
                    } finally {
                        loadedCount++;
                        this.showFolderLoading(loadedCount, validFiles.length);
                    }
                }
                this.hideFolderLoading();
            }

            handleBackgroundImage(files) {
                if (!files || files.length === 0) return;
                const file = files[0];
                if (!file.type.startsWith('image/')) {
                    this.showError('Please select an image file for the background.');
                    return;
                }

                this.showLoading();
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        this.hideLoading();
                        const uniqueId = 'bg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                        this.addToBackgroundAssetsPanel(img, uniqueId, 'background');
                        this.drawBackground(img, uniqueId); // Draw directly to canvas
                        this.showShortcutFeedback('Background image set');
                    };
                    img.onerror = () => {
                        this.hideLoading();
                        this.showError('Failed to load background image.');
                    };
                    img.src = e.target.result;
                };
                reader.onerror = () => {
                    this.hideLoading();
                    this.showError('Failed to read background image file.');
                };
                reader.readAsDataURL(file);
            }

            /**
             * Processes and sets a foreground image from a file.
             * @param {File} file The file object.
             */
            async processAndSetForegroundImage(file) {
                this.showLoading();
                let img;
                let uniqueId;
                let assetType;

                try {
                    if (!file || !file.type.startsWith('image/')) {
                        this.showError('Please select an image file for the foreground.');
                        this.hideLoading();
                        return;
                    }
                    const dataUrl = await new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = (e) => resolve(e.target.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(file);
                    });
                    img = await this.loadImageElement(dataUrl);
                    uniqueId = 'fg_file_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    assetType = 'foreground_image_file';

                    this.hideLoading();
                    // Add to assets panel
                    this.addToForegroundAssetsPanel(img, uniqueId, assetType);
                    // Draw directly on the canvas as a fixed foreground layer
                    this.drawForeground(img, uniqueId); 
                    this.showShortcutFeedback('Foreground image added to library and set'); 
                } catch (error) {
                    this.hideLoading();
                    this.showError('Failed to set foreground image: ' + error.message);
                }
            }


            /** Konva Drawing Functions **/

            drawBackground(img, uniqueId) {
                this.backgroundLayer.destroyChildren();

                const stageWidth = this.stage.width();
                const stageHeight = this.stage.height();

                const scaleX = stageWidth / img.width;
                const scaleY = stageHeight / img.height;
                const scale = Math.max(scaleX, scaleY);

                const newWidth = img.width * scale;
                const newHeight = img.height * scale;

                const x = (stageWidth - newWidth) / 2;
                const y = (stageHeight - newHeight) / 2;

                this.currentBackgroundNode = new Konva.Image({
                    image: img,
                    x: x,
                    y: y,
                    width: newWidth,
                    height: newHeight,
                    draggable: false, // Fixed layer, not draggable by mouse
                    listening: true, // Background can be clicked to select
                    name: 'background_image',
                    id: uniqueId
                });

                this.currentBackgroundNode.on('click tap', () => this.updateActiveElement(this.currentBackgroundNode));
                this.currentBackgroundNode.on('transformend', () => {
                    // This transformend event handler will likely not fire if draggable is false,
                    // but keeping it for completeness in case it's used for programmatic transforms.
                    this.resizeStage();
                    this.backgroundLayer.draw();
                });

                this.backgroundLayer.add(this.currentBackgroundNode);
                this.backgroundLayer.draw();
                this.updateActiveElement(this.currentBackgroundNode);
            }

            drawForeground(img, uniqueId) {
                this.foregroundLayer.destroyChildren();

                const stageWidth = this.stage.width();
                const stageHeight = this.stage.height();

                const scaleX = stageWidth / img.width;
                const scaleY = stageHeight / img.height;
                const scale = Math.max(scaleX, scaleY);

                const newWidth = img.width * scale;
                const newHeight = img.height * scale;

                const x = (stageWidth - newWidth) / 2;
                const y = (stageHeight - newHeight) / 2;

                this.currentForegroundNode = new Konva.Image({
                    image: img,
                    x: x,
                    y: y,
                    width: newWidth,
                    height: newHeight,
                    draggable: false, // Fixed layer, not draggable
                    listening: false, // IMPORTANT: Allows clicks to pass through to layers below
                    name: 'foreground_image',
                    id: uniqueId
                });

                // Removed click tap listener as it will not respond to mouse events
                // this.currentForegroundNode.on('click tap', () => this.updateActiveElement(this.currentForegroundNode)); 
                this.currentForegroundNode.on('transformend', () => {
                     // This transformend event handler will likely not fire if draggable is false,
                    // but keeping it for completeness in case it's used for programmatic transforms.
                    this.resizeStage();
                    this.foregroundLayer.draw();
                });

                this.foregroundLayer.add(this.currentForegroundNode);
                this.foregroundLayer.draw();
                // Removed updateActiveElement call to prevent automatic selection on creation
                // this.updateActiveElement(this.currentForegroundNode); 
            }

            drawImage(image, x, y, uniqueId) { 
                const maxWidth = this.stage.width() * 0.9;
                const maxHeight = this.stage.height() * 0.9;
                const centerX = this.stage.width() / 2;
                const centerY = this.stage.height() / 2;
                
                const scaleX = maxWidth / image.width;
                const scaleY = maxHeight / image.height;
                const scale = Math.min(scaleX, scaleY, 1);
                
                const finalWidth = image.width * scale;
                const finalHeight = image.height * scale;

                const konvaImage = new Konva.Image({
                    image: image,
                    x: centerX - finalWidth / 2,
                    y: centerY - finalHeight / 2,
                    width: finalWidth,
                    height: finalHeight,
                    draggable: true,
                    id: uniqueId,
                });
                this.layer.add(konvaImage);
                konvaImage.on('click tap', () => this.updateActiveElement(konvaImage));
                konvaImage.on('transformend', () => this.layer.draw());
                this.mediaElements.set(konvaImage.id(), konvaImage);
                this.layer.draw();
                this.updateActiveElement(konvaImage);
            }

            drawAnimatedGif(image, x, y, src, uniqueId) {
                const gifImageElement = document.createElement('img');
                gifImageElement.src = src;
                gifImageElement.style.position = 'absolute';
                gifImageElement.style.left = '-9999px';
                gifImageElement.style.top = '-9999px';
                gifImageElement.style.visibility = 'hidden';
                gifImageElement.style.pointerEvents = 'none';
                document.getElementById('gif-container').appendChild(gifImageElement);

                gifler(src).frames((frames, ctrl) => {
                    const maxWidth = this.stage.width() * 0.9;
                    const maxHeight = this.stage.height() * 0.9;
                    const centerX = this.stage.width() / 2;
                    const centerY = this.stage.height() / 2;
                    
                    const scaleX = maxWidth / frames[0].image.width;
                    const scaleY = maxHeight / frames[0].image.height;
                    const scale = Math.min(scaleX, scaleY, 1);
                    
                    const finalWidth = frames[0].image.width * scale;
                    const finalHeight = frames[0].image.height * scale;

                    const konvaGif = new Konva.Image({
                        image: frames[0].image,
                        x: centerX - finalWidth / 2,
                        y: centerY - finalHeight / 2,
                        width: finalWidth,
                        height: finalHeight,
                        draggable: true,
                        id: uniqueId,
                        gifCtrl: ctrl
                    });

                    this.layer.add(konvaGif);
                    konvaGif.on('click tap', () => this.updateActiveElement(konvaGif));
                    konvaGif.on('transformend', () => this.layer.draw());
                    this.mediaElements.set(konvaGif.id(), konvaGif);
                    this.layer.draw();
                    this.updateActiveElement(konvaGif);

                    this.activeGifAnimations.set(konvaGif.id(), ctrl);

                    let frameIndex = 0;
                    const animateGif = () => {
                        const frame = frames[frameIndex];
                        konvaGif.image(frame.image);
                        this.layer.draw();

                        frameIndex = (frameIndex + 1) % frames.length;
                        konvaGif.gifAnimationId = setTimeout(animateGif, frame.delay);
                    };
                    konvaGif.gifAnimationId = setTimeout(animateGif, frames[0].delay);
                });
            }

            drawVideo(videoElement, x, y, uniqueId) { 
                const maxWidth = this.stage.width() * 0.9;
                const maxHeight = this.stage.height() * 0.9;
                const centerX = this.stage.width() / 2;
                const centerY = this.stage.height() / 2;

                const aspectRatio = videoElement.videoWidth / videoElement.videoHeight;
                
                let width = videoElement.videoWidth;
                let height = videoElement.videoHeight;

                if (width > maxWidth) {
                    width = maxWidth;
                    height = maxWidth / aspectRatio;
                }
                if (height > maxHeight) {
                    height = maxHeight;
                    width = maxHeight * aspectRatio;
                }

                const konvaVideo = new Konva.Image({
                    image: videoElement,
                    x: centerX - width / 2,
                    y: centerY - height / 2,
                    width: width,
                    height: height,
                    draggable: true,
                    stroke: 'white',
                    strokeWidth: 2,
                    id: uniqueId,
                });

                this.layer.add(konvaVideo);
                konvaVideo.on('click tap', () => this.updateActiveElement(konvaVideo));
                konvaVideo.on('transformend', () => this.layer.draw());
                this.mediaElements.set(konvaVideo.id(), konvaVideo);
                this.layer.draw();
                this.updateActiveElement(konvaVideo);

                const videoAnimation = new Konva.Animation(() => {}, this.layer);
                this.activeAnimations.set(konvaVideo.id(), videoAnimation);
                videoAnimation.start();
            }

            addTextNode(text = 'New Text', x, y, fontSize = 24, fill = '#ffffff', fontFamily = 'Arial', uniqueId = 'text_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9)) {
                const textNode = new Konva.Text({
                    text: text,
                    x: x,
                    y: y,
                    fontSize: fontSize,
                    fontFamily: fontFamily,
                    fill: fill,
                    draggable: true,
                    width: 200, // Initial width for wrapping
                    padding: 10,
                    align: 'center',
                    id: uniqueId,
                });
                this.layer.add(textNode);
                textNode.on('click tap', () => this.updateActiveElement(textNode));
                textNode.on('transformend', () => {
                    // Update width/height based on scaling
                    textNode.width(textNode.width() * textNode.scaleX());
                    textNode.height(textNode.height() * textNode.scaleY());
                    textNode.scaleX(1);
                    textNode.scaleY(1);
                    this.layer.draw();
                });
                this.mediaElements.set(textNode.id(), textNode);
                this.layer.draw();
                this.updateActiveElement(textNode);
                return textNode;
            }

            /** Asset Panel Management **/

            addToAssetsPanel(asset, id, type) {
                const assetContainer = this.createAssetContainer(asset, id, type, this.elements.assetsList);
                this.assetCache.set(id, { asset, type, src: asset.src }); 
                this.openAssetsPanel();
            }

            addToBackgroundAssetsPanel(asset, id, type) {
                const assetContainer = this.createAssetContainer(asset, id, type, this.elements.backgroundAssetsList);
                this.assetCache.set(id, { asset, type, src: asset.src });
                this.openAssetsPanel();
            }

            addToForegroundAssetsPanel(asset, id, type) {
                const assetContainer = this.createAssetContainer(asset, id, type, this.elements.foregroundAssetsList);
                this.assetCache.set(id, { asset, type, src: asset.src }); 
                this.openAssetsPanel();
            }

            createAssetContainer(asset, id, type, parentElement) {
                const assetContainer = document.createElement('div');
                assetContainer.className = 'asset-container';
                assetContainer.draggable = true;
                assetContainer.dataset.assetId = id;
                assetContainer.dataset.assetType = type;

                let thumbnailSrc;
                if (type === 'image' || type === 'gif' || type === 'background' || type === 'foreground_image_file') {
                    thumbnailSrc = asset.src;
                } else if (type === 'video') {
                    const canvas = document.createElement('canvas');
                    canvas.width = 160;
                    canvas.height = 90;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(asset, 0, 0, canvas.width, canvas.height);
                    thumbnailSrc = canvas.toDataURL('image/png');
                } else {
                    // This should not be reached for any valid asset types now
                    return null; 
                }

                if (thumbnailSrc) {
                    const thumbnail = document.createElement('img');
                    thumbnail.src = thumbnailSrc;
                    thumbnail.alt = `Asset Thumbnail ${id}`;
                    thumbnail.className = 'asset-thumbnail';
                    assetContainer.appendChild(thumbnail);
                }

                if (type === 'gif') {
                    const gifIndicator = document.createElement('span');
                    gifIndicator.className = 'gif-indicator';
                    gifIndicator.textContent = 'GIF';
                    assetContainer.appendChild(gifIndicator);
                } else if (type === 'video') {
                    const videoIndicator = document.createElement('span');
                    videoIndicator.className = 'gif-indicator';
                    videoIndicator.textContent = 'VIDEO';
                    videoIndicator.style.backgroundColor = '#007bff';
                    assetContainer.appendChild(videoIndicator);
                }

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'asset-delete-btn';
                deleteBtn.innerHTML = '&times;';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    // Determine if it's a fixed layer (background/foreground) for deletion logic
                    const isFixedLayer = (type === 'background' || type === 'foreground_image_file');
                    this.deleteAsset(id, assetContainer, isFixedLayer);
                };
                assetContainer.appendChild(deleteBtn);

                parentElement.appendChild(assetContainer);
                return assetContainer;
            }

            deleteAsset(id, element = null, isFixedLayer = false) {
                const userConfirmed = true; // In a real app, use a custom modal for confirmation

                if (userConfirmed) {
                    let konvaNodeToRemove = null;
                    if (isFixedLayer) {
                        if (this.currentBackgroundNode && this.currentBackgroundNode.id() === id) {
                            konvaNodeToRemove = this.currentBackgroundNode;
                            this.currentBackgroundNode = null;
                        } else if (this.currentForegroundNode && this.currentForegroundNode.id() === id) {
                            konvaNodeToRemove = this.currentForegroundNode;
                            this.currentForegroundNode = null;
                        }
                    } else {
                        konvaNodeToRemove = this.layer.find(node => node.id() === id)[0];
                    }

                    if (konvaNodeToRemove) {
                        if (this.activeGifAnimations.has(konvaNodeToRemove.id())) {
                            clearTimeout(konvaNodeToRemove.gifAnimationId);
                            this.activeGifAnimations.delete(konvaNodeToRemove.id());
                        }
                        if (this.activeAnimations.has(konvaNodeToRemove.id())) {
                            this.activeAnimations.get(konvaNodeToRemove.id()).stop();
                            this.activeAnimations.delete(konvaNodeToRemove.id());
                        }
                        if (konvaNodeToRemove.image() && konvaNodeToRemove.image().tagName === 'VIDEO') {
                             konvaNodeToRemove.image().remove(); // Remove HTML video element
                        }

                        konvaNodeToRemove.destroy();
                        if (this.transformer.nodes().includes(konvaNodeToRemove)) {
                            this.transformer.nodes([]);
                        }
                        this.mediaElements.delete(konvaNodeToRemove.id());
                        this.layer.draw();
                        if (this.backgroundLayer) this.backgroundLayer.draw();
                        if (this.foregroundLayer) this.foregroundLayer.draw();
                        this.showShortcutFeedback('Item deleted from canvas');
                    } else {
                        console.log('Konva node not found on canvas or already deleted:', id);
                    }

                    if (element) {
                        element.remove();
                        this.assetCache.delete(id);
                        this.showShortcutFeedback('Item removed from library');
                    }
                }
            }

            /** Drag & Drop Handlers **/

            handleAssetDragStart(e) {
                if (e.target.classList.contains('asset-thumbnail')) {
                    const assetContainer = e.target.closest('.asset-container');
                    if (assetContainer) {
                        e.dataTransfer.setData('text/plain', assetContainer.dataset.assetId);
                        e.dataTransfer.effectAllowed = 'copy';
                    }
                }
            }

            handleDragOver(e) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
                this.elements.container.classList.add('drag-over');
            }

            handleDragLeave() {
                this.elements.container.classList.remove('drag-over');
            }

            async handleDrop(e) {
                e.preventDefault();
                this.elements.container.classList.remove('drag-over');

                const assetId = e.dataTransfer.getData('text/plain');
                if (!assetId) {
                    console.warn('[handleDrop] No asset ID found in dataTransfer.');
                    return;
                }

                const assetData = this.assetCache.get(assetId);
                if (!assetData) {
                    this.showError('Asset not found in cache.');
                    console.error('[handleDrop] Asset data not found for ID:', assetId);
                    return;
                }
                console.log('[handleDrop] Dropped asset type:', assetData.type, 'ID:', assetId);

                const pointerPosition = this.stage.getPointerPosition();
                const dropX = pointerPosition.x;
                const dropY = pointerPosition.y;

                this.showLoading();
                try {
                    switch (assetData.type) {
                        case 'image':
                            const img = await this.loadImageElement(assetData.src);
                            this.drawImage(img, dropX, dropY, assetId);
                            break;
                        case 'gif':
                            const gifImg = await this.loadImageElement(assetData.src);
                            this.drawAnimatedGif(gifImg, dropX, dropY, assetData.src, assetId);
                            break;
                        case 'video':
                            const videoElement = assetData.asset; // Reuse existing video element
                            this.drawVideo(videoElement, dropX, dropY, assetId);
                            break;
                        case 'background':
                            const bgImg = await this.loadImageElement(assetData.src);
                            this.drawBackground(bgImg, assetId);
                            this.showShortcutFeedback('Background image set');
                            break;
                        case 'foreground_image_file':
                            const fgImg = await this.loadImageElement(assetData.src);
                            // When dragging from the media library, add as a draggable image to the main layer
                            this.drawImage(fgImg, dropX, dropY, assetId);
                            this.showShortcutFeedback('Foreground image added as draggable');
                            break;
                        default:
                            this.showError('Unsupported asset type for drop.');
                            break;
                    }
                    this.hideLoading();
                } 
                catch (error) { 
                    this.hideLoading();
                    this.showError('Error dropping asset: ' + error.message);
                }
            }

            /** UI Actions & Hotkeys **/

            toggleFullscreen() {
                try {
                    if (document.fullscreenElement) {
                        document.exitFullscreen();
                    } else {
                        document.documentElement.requestFullscreen();
                    }
                } catch (e) {
                    console.error("Fullscreen error:", e);
                    this.showError("Fullscreen functionality is blocked by browser or permissions policy.");
                }
            }

            updateFullscreenButton() {
                const button = this.elements.toolbar.querySelector('#fullscreenToggle');
                button.innerHTML = '‚õ∂'; // Always same icon, only title changes
                button.title = document.fullscreenElement ? 'Exit Fullscreen - Press F11' : 'Toggle Fullscreen - Press F11';
            }

            handleHotkeys(e) {
                const selectedNode = this.getTargetNode();

                if (e.key === 'Delete' || e.key === 'Backspace') {
                    if (selectedNode) {
                        // Check if it's a fixed layer (background/foreground) or a general media element
                        const isFixed = (selectedNode.name() === 'background_image' || selectedNode.name() === 'foreground_image');
                        this.deleteAsset(selectedNode.id(), null, isFixed);
                        if (this.lastSelectedNode === selectedNode) {
                            this.lastSelectedNode = null;
                        }
                        e.preventDefault();
                    } else {
                        this.showError('Select an item first or no previous selection found.');
                    }
                }

                if (e.ctrlKey) {
                    switch (e.key) {
                        case '1': e.preventDefault(); this.applyShakeAnimation(); break;
                        case '2': e.preventDefault(); this.applyCircleAnimation(); break;
                        case '3': e.preventDefault(); this.showAnimationSettings(); break;
                        case '4': e.preventDefault(); this.applyFlipAnimation(); break;
                        case 'ArrowUp': e.preventDefault(); this.moveLayerUp(); break;
                        case 'ArrowDown': e.preventDefault(); this.moveLayerDown(); break;
                    }
                }
                if (e.key === 'F11') {
                    e.preventDefault();
                    this.toggleFullscreen();
                }
            }

            increaseSize() {
                const node = this.getTargetNode();
                if (node) {
                    if (node.name() === 'background_image' || node.name() === 'foreground_image') {
                        this.showError('Background and Foreground images are scaled automatically to fit the canvas and cannot be resized manually.');
                        return;
                    }
                    node.scaleX(node.scaleX() * 1.1);
                    node.scaleY(node.scaleY() * 1.1);
                    this.layer.draw();
                    this.showShortcutFeedback('Increased Size');
                } else {
                    this.showError('Select an item first or no previous selection found.');
                }
            }

            decreaseSize() {
                const node = this.getTargetNode();
                if (node) {
                    if (node.name() === 'background_image' || node.name() === 'foreground_image') {
                        this.showError('Background and Foreground images are scaled automatically to fit the canvas and cannot be resized manually.');
                        return;
                    }
                    node.scaleX(node.scaleX() * 0.9);
                    node.scaleY(node.scaleY() * 0.9);
                    this.layer.draw();
                    this.showShortcutFeedback('Decreased Size');
                } else {
                    this.showError('Select an item first or no previous selection found.');
                }
            }

            deleteSelectedItem() {
                const node = this.getTargetNode();
                if (node) {
                    const isFixed = (node.name() === 'background_image' || node.name() === 'foreground_image');
                    this.deleteAsset(node.id(), null, isFixed);
                    if (this.lastSelectedNode === node) {
                        this.lastSelectedNode = null;
                    }
                } else {
                    this.showError('Select an item first or no previous selection found.');
                }
            }

            moveLayerUp() {
                const node = this.getTargetNode();
                if (node) {
                    if (node.name() === 'background_image' || node.name() === 'foreground_image') {
                        this.showError('Background and Foreground images cannot be reordered as they are fixed layers.');
                        return;
                    }
                    node.moveUp();
                    this.layer.draw();
                    this.showShortcutFeedback('Moved layer up');
                } else {
                    this.showError('Select an item first or no previous selection found.');
                }
            }

            moveLayerDown() {
                const node = this.getTargetNode();
                if (node) {
                    if (node.name() === 'background_image' || node.name() === 'foreground_image') {
                        this.showError('Background and Foreground images cannot be reordered as they are fixed layers.');
                        return;
                    }
                    node.moveDown();
                    this.layer.draw();
                    this.showShortcutFeedback('Moved layer down');
                } else {
                    this.showError('Select an item first or no previous selection found.');
                }
            }

            applyShakeAnimation() {
                const node = this.getTargetNode();
                if (node) {
                    if (node.name() === 'background_image' || node.name() === 'foreground_image') {
                        this.showError('Background and Foreground images cannot be animated as they are fixed layers.');
                        return;
                    }
                    if (this.activeAnimations.has(node.id())) {
                        this.activeAnimations.get(node.id()).stop();
                        this.activeAnimations.delete(node.id());
                    }
                    
                    const initialX = node.x();
                    const amplitude = this.shakeSettings.distance / 2;
                    const duration = 2000 / this.shakeSettings.speed;
                    let startTime = null;

                    const shakeAnimation = new Konva.Animation((frame) => {
                        if (!startTime) startTime = frame.time;
                        const elapsed = frame.time - startTime;
                        
                        if (elapsed >= duration) {
                            node.x(initialX);
                            shakeAnimation.stop();
                            this.activeAnimations.delete(node.id());
                            this.layer.draw();
                            return;
                        }

                        const progress = elapsed / duration;
                        const cycles = this.shakeSettings.repetitions;
                        const newX = initialX + amplitude * Math.sin(progress * cycles * Math.PI * 2);
                        node.x(newX);
                    }, this.layer);

                    this.activeAnimations.set(node.id(), shakeAnimation);
                    shakeAnimation.start();
                    this.showShortcutFeedback('Shake Animation applied');
                } else {
                    this.showError('Select an item first or no previous selection found.');
                }
            }

            applyCircleAnimation() {
                const node = this.getTargetNode();
                if (node) {
                    if (node.name() === 'background_image' || node.name() === 'foreground_image') {
                        this.showError('Background and Foreground images cannot be animated as they are fixed layers.');
                        return;
                    }
                    if (this.activeAnimations.has(node.id())) {
                        this.activeAnimations.get(node.id()).stop();
                        this.activeAnimations.delete(node.id());
                    }
                    
                    const initialX = node.x();
                    const initialY = node.y();
                    
                    const nodeCenterX = initialX + node.width() / 2;
                    const nodeCenterY = initialY + node.height() / 2;

                    const radius = this.circleSettings.radius;
                    const duration = 3000 / this.circleSettings.speed;
                    let startTime = null;

                    const startAngle = Math.atan2(initialY - nodeCenterY, initialX - nodeCenterX);

                    const circleAnimation = new Konva.Animation((frame) => {
                        if (!startTime) startTime = frame.time;
                        const elapsed = frame.time - startTime;
                        
                        if (elapsed >= duration) {
                            node.x(initialX);
                            node.y(initialY);
                            circleAnimation.stop();
                            this.activeAnimations.delete(node.id());
                            this.layer.draw();
                            return;
                        }

                        const progress = elapsed / duration;
                        const cycles = this.circleSettings.repetitions;
                        const angle = startAngle + progress * cycles * Math.PI * 2; 

                        node.x(nodeCenterX + radius * Math.cos(angle) - node.width() / 2);
                        node.y(nodeCenterY + radius * Math.sin(angle) - node.height() / 2);
                    }, this.layer);

                    this.activeAnimations.set(node.id(), circleAnimation);
                    circleAnimation.start();
                    this.showShortcutFeedback('Circle Animation applied');
                } else {
                    this.showError('Select an item first or no previous selection found.');
                }
            }

            applyFlipAnimation() {
                const node = this.getTargetNode();
                if (node) {
                    if (node.name() === 'background_image' || node.name() === 'foreground_image') {
                        this.showError('Background and Foreground images cannot be animated as they are fixed layers.');
                        return;
                    }
                    if (this.activeAnimations.has(node.id())) {
                        this.activeAnimations.get(node.id()).stop();
                        this.activeAnimations.delete(node.id());
                    }
                    
                    const startScaleX = node.scaleX();
                    const targetScaleX = -startScaleX;
                    
                    const centerX = node.x() + (node.width() * startScaleX) / 2;
                    const centerY = node.y() + node.height() / 2;
                    
                    const duration = 1000 / this.flipSettings.speed;
                    let startTime = null;

                    const flipAnimation = new Konva.Animation((frame) => {
                        if (!startTime) startTime = frame.time;
                        const elapsed = frame.time - startTime;
                        
                        if (elapsed >= duration) {
                            node.scaleX(targetScaleX);
                            node.x(centerX - (node.width() * targetScaleX) / 2);
                            node.y(centerY - node.height() / 2);
                            flipAnimation.stop();
                            this.activeAnimations.delete(node.id());
                            this.layer.draw();
                            return;
                        }

                        const progress = elapsed / duration;
                        const scaleProgress = Math.cos(progress * Math.PI);
                        const currentScaleX = startScaleX + (targetScaleX - startScaleX) * (1 - scaleProgress) / 2;
                        
                        node.scaleX(currentScaleX);
                        node.x(centerX - (node.width() * currentScaleX) / 2);
                        node.y(centerY - node.height() / 2);
                    }, this.layer);

                    this.activeAnimations.set(node.id(), flipAnimation);
                    flipAnimation.start();
                    this.showShortcutFeedback('Flip Animation applied');
                } else {
                    this.showError('Select an item first or no previous selection found.');
                }
            }

            showAnimationSettings() {
                this.elements.shakeSpeedSlider.value = this.shakeSettings.speed;
                this.elements.shakeSpeedValueDisplay.textContent = `${this.shakeSettings.speed}x`;
                this.elements.shakeRepetitionsInput.value = this.shakeSettings.repetitions;
                this.elements.shakeDistanceSlider.value = this.shakeSettings.distance;
                this.elements.shakeDistanceValueDisplay.textContent = `${this.shakeSettings.distance}px`;

                this.elements.circleSpeedSlider.value = this.circleSettings.speed;
                this.elements.circleSpeedValueDisplay.textContent = `${this.circleSettings.speed}x`;
                this.elements.circleRepetitionsInput.value = this.circleSettings.repetitions;
                this.elements.circleRadiusSlider.value = this.circleSettings.radius;
                this.elements.circleRadiusValueDisplay.textContent = `${this.circleSettings.radius}px`;

                this.elements.flipSpeedSlider.value = this.flipSettings.speed;
                this.elements.flipSpeedValueDisplay.textContent = `${this.flipSettings.speed}x`;
                this.elements.flipRepetitionsInput.value = this.flipSettings.repetitions;

                this.elements.animationSettingsMenu.style.display = 'block';
            }

            saveAnimationSettings() {
                this.shakeSettings = {
                    speed: parseFloat(this.elements.shakeSpeedSlider.value),
                    repetitions: parseInt(this.elements.shakeRepetitionsInput.value),
                    distance: parseInt(this.elements.shakeDistanceSlider.value)
                };
                this.circleSettings = {
                    speed: parseFloat(this.elements.circleSpeedSlider.value),
                    repetitions: parseInt(this.elements.circleRepetitionsInput.value),
                    radius: parseInt(this.elements.circleRadiusSlider.value)
                };
                this.flipSettings = {
                    speed: parseFloat(this.elements.flipSpeedSlider.value),
                    repetitions: parseInt(this.elements.flipRepetitionsInput.value)
                };
                this.elements.animationSettingsMenu.style.display = 'none';
                this.showShortcutFeedback('Animation settings saved');
            }

            showTextPopup() {
                this.elements.textPopup.style.display = 'block';
                this.elements.popupTextInput.value = 'New Text';
                this.elements.colorPicker.value = '#ffffff';
                this.elements.fontPicker.value = 'Arial';
                this.elements.fontSizeSlider.value = '24';
                this.elements.fontSizeValue.textContent = '24px';
                this.updateTextPreview();
            }

            updateTextPreview() {
                this.elements.textPreview.textContent = this.elements.popupTextInput.value || 'Preview Text';
                this.elements.textPreview.style.color = this.elements.colorPicker.value;
                this.elements.textPreview.style.fontFamily = this.elements.fontPicker.value;
                this.elements.textPreview.style.fontSize = `${this.elements.fontSizeSlider.value}px`;
                
                const hex = this.elements.colorPicker.value.substring(1);
                const r = parseInt(hex.substring(0, 2), 16);
                const g = parseInt(hex.substring(2, 4), 16);
                const b = parseInt(hex.substring(4, 6), 16);
                const brightness = ((r * 299) + (g * 587) + (b * 114)) / 1000;
                this.elements.textPreview.style.backgroundColor = brightness > 125 ? 'rgba(0,0,0,0.6)' : 'rgba(255,255,255,0.2)';
            }

            addTextToCanvas() {
                const textContent = this.elements.popupTextInput.value || 'New Text';
                const color = this.elements.colorPicker.value;
                const font = this.elements.fontPicker.value;
                const fontSize = parseInt(this.elements.fontSizeSlider.value);
                const uniqueId = 'text_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

                // Calculate center position for the new text node
                const centerX = this.stage.width() / 2;
                const centerY = this.stage.height() / 2;

                this.addTextNode(textContent, centerX, centerY, fontSize, color, font, uniqueId);
                
                this.elements.textPopup.style.display = 'none';
                this.showShortcutFeedback('Text added to Canvas');
            }

            makeTextPopupDraggable() {
                let isDraggingTextPopup = false;
                let textPopupOffsetX, textPopupOffsetY;

                this.elements.textPopupTitleBar.addEventListener('mousedown', (e) => {
                    isDraggingTextPopup = true;
                    textPopupOffsetX = e.clientX - this.elements.textPopup.getBoundingClientRect().left;
                    textPopupOffsetY = e.clientY - this.elements.textPopup.getBoundingClientRect().top;
                    this.elements.textPopup.style.cursor = 'grabbing';
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isDraggingTextPopup) return;
                    this.elements.textPopup.style.left = `${e.clientX - textPopupOffsetX}px`;
                    this.elements.textPopup.style.top = `${e.clientY - textPopupOffsetY}px`;
                });

                document.addEventListener('mouseup', () => {
                    isDraggingTextPopup = false;
                    this.elements.textPopup.style.cursor = 'grab';
                });
            }

            openAssetsPanel() {
                if (!this.elements.assetsPanel.classList.contains('expanded')) {
                    this.elements.assetsPanel.classList.add('expanded');
                    this.elements.assetsPanelToggle.innerHTML = '‚ñ∂';
                    this.elements.assetsPanelToggle.title = 'Collapse Media Library';
                }
            }

            toggleAssetsPanel() {
                this.elements.assetsPanel.classList.toggle('expanded');
                if (this.elements.assetsPanel.classList.contains('expanded')) {
                    this.elements.assetsPanelToggle.innerHTML = '‚ñ∂';
                    this.elements.assetsPanelToggle.title = 'Collapse Media Library';
                } else {
                    this.elements.assetsPanelToggle.innerHTML = '‚óÄ';
                    this.elements.assetsPanelToggle.title = 'Expand Media Library';
                }
            }

            resizeStage() {
                if (!this.stage) return;
                const toolbarWidth = this.elements.toolbar.offsetWidth;
                // Account for the assets panel if it's expanded
                const assetsPanelWidth = this.elements.assetsPanel.classList.contains('expanded') ? this.elements.assetsPanel.offsetWidth : 0;
                this.stage.width(window.innerWidth - toolbarWidth - assetsPanelWidth);
                this.stage.height(window.innerHeight);

                const repositionFixedLayer = (node) => {
                    if (!node || !node.image()) return;
                    const img = node.image();
                    const stageWidth = this.stage.width();
                    const stageHeight = this.stage.height();

                    const scaleX = stageWidth / img.width;
                    const scaleY = stageHeight / img.height;
                    const scale = Math.max(scaleX, scaleY);

                    const newWidth = img.width * scale;
                    const newHeight = img.height * scale;

                    const x = (stageWidth - newWidth) / 2;
                    const y = (stageHeight - newHeight) / 2;

                    node.setAttrs({ x: x, y: y, width: newWidth, height: newHeight });
                };

                repositionFixedLayer(this.currentBackgroundNode);
                if (this.currentBackgroundNode) this.backgroundLayer.draw();

                repositionFixedLayer(this.currentForegroundNode);
                if (this.currentForegroundNode) this.foregroundLayer.draw();
                
                this.layer.draw(); // Redraw main layer to ensure draggable elements are visible
            }

            changeBackgroundColor(color) {
                this.elements.container.style.backgroundColor = color;
                this.showShortcutFeedback(`Background changed to ${color}`);
            }

            /** Cleanup **/
            cleanup() {
                this.activeGifAnimations.forEach((animation) => {
                    if (animation && animation.stop) {
                        animation.stop();
                    }
                });
                this.activeGifAnimations.clear();

                this.activeAnimations.forEach((animation) => {
                    if (animation && animation.stop) {
                        animation.stop();
                    }
                });
                this.activeAnimations.clear();

                this.mediaElements.forEach((element) => {
                    if (element.pause) element.pause();
                    if (element.remove) element.remove();
                });
                this.mediaElements.clear();
                
                this.assetCache.clear(); 
            }
        }

        // Initialize the app when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => new GazeTrackerApp().init());
        } else {
            new GazeTrackerApp().init();
        }
    </script>
</body>
</html>
